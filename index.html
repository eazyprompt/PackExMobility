<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
  />
  <title>PackEx: Smart Corrugated + Glue Gap</title>

  <link rel="icon" type="image/png" href="./logo.png" />
  <link rel="apple-touch-icon" href="./logo.png" />
  <meta name="theme-color" content="#020617" />

  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;800&family=JetBrains+Mono:wght@500;700;800&display=swap"
    rel="stylesheet"
  />
  <script src="https://cdn.jsdelivr.net/npm/lucide@0.321.0/dist/umd/lucide.min.js"></script>

  <style>
    :root {
      --bg-body: #0f172a;
      --bg-card: #1e293b;
      --bg-sidebar: #172554;
      --border-subtle: rgba(255, 255, 255, 0.12);
      --text-main: #ffffff;
      --text-muted: #94a3b8;
      --primary: #3b82f6;
      --primary-glow: rgba(59, 130, 246, 0.5);
      --sample: #ffffff;
      --success: #34d399;
      --warn: #fbbf24;
      --danger: #f87171;
      --neon-green: #00ff41;
      --radius-lg: 18px;
      --font-ui: "Inter", sans-serif;
      --font-num: "JetBrains Mono", monospace;

      --frame-gap: clamp(18px, 6.5vw, 72px);
      --gap-layout: 16px;
      --viewport-h: 220px;
      --viz-h: 150px;
      --app-h: 100dvh;
      --tab-h: 60px;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }

    body {
      background: #020617;
      color: var(--text-main);
      font-family: var(--font-ui);
      margin: 0;
      width: 100vw;
      height: var(--app-h);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    body::after{
      content:""; position: fixed; inset: 0; background: rgba(255,255,255,0.85);
      opacity: 0; pointer-events: none; transition: opacity 120ms ease; z-index: 9999;
    }
    body.screen-flash::after{ opacity: 1; }
    body.screen-lamp::after{ opacity: 1; }

    .app-frame {
      width: calc(100vw - (var(--frame-gap) * 2));
      height: calc(var(--app-h) - (var(--frame-gap) * 2));
      max-width: 500px;
      max-height: calc(var(--app-h) - (var(--frame-gap) * 2));
      background: var(--bg-body);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
      border-radius: 24px;
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.6), 0 0 0 1px var(--border-subtle);
      padding-top: env(safe-area-inset-top);
      padding-bottom: 0;
    }

    header {
      min-height: 64px;
      padding: 0 20px;
      padding-top: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--bg-body);
      border-bottom: 1px solid var(--border-subtle);
      flex-shrink: 0;
      z-index: 50;
      gap: 10px;
      min-width: 0;
    }

    .brand {
      font-weight: 800; font-size: 1.25rem; display: flex; align-items: center; gap: 10px; color: #fff;
      min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .brand i { color: var(--primary); }
    .brand span { color: var(--primary); font-weight: 400; opacity: 0.9; font-size: 0.8em; }

    .header-controls { display: flex; align-items: center; gap: 10px; min-width: 0; }

    .algo-selector {
      appearance: none; background: #334155; color: #fff; border: 1px solid var(--border-subtle);
      padding: 8px 14px; border-radius: 100px; font-size: 0.75rem; font-weight: 600;
      font-family: var(--font-num); transition: 0.2s; min-width: 0; max-width: 160px;
    }

    .btn-icon-header {
      background: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-subtle); color: #fff;
      width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
      cursor: pointer; transition: 0.2s; flex-shrink: 0;
    }

    .dash-right { display:flex; align-items:center; gap:10px; flex-shrink: 0; min-width: 0; }
    .btn-icon-dash { width: 38px; height: 38px; }

    .viewport {
      height: var(--viewport-h);
      min-height: 0;
      display: flex;
      background: #020617;
      border-bottom: 1px solid var(--border-subtle);
      flex-shrink: 0;
      position: relative;
    }

    .vp-camera {
      flex: 1; position: relative; overflow: hidden; display: flex;
      align-items: center; justify-content: center; border-right: 1px solid var(--border-subtle);
      background: #020617; min-width: 0;
      transition: flex 0.3s ease;
    }

    .vp-camera.full-width { border-right: none; }

    video { width: 100%; height: 100%; object-fit: cover; opacity: 1.0; position: relative; z-index: 1; }

    .ghost-overlay {
      position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover;
      opacity: 0; pointer-events: none; z-index: 5; transition: opacity 0.3s ease; filter: grayscale(0.2);
    }
    .ghost-overlay.active { opacity: 0.35; }

    #sheet-canvas {
        position: absolute; inset:0; width:100%; height:100%;
        pointer-events:none; z-index: 20;
    }

    .vp-side-panel {
      flex: 1; background: var(--bg-sidebar); display: flex; flex-direction: column;
      padding: 16px; overflow-y: auto; flex-shrink: 0;
      box-shadow: inset 5px 0 15px rgba(0, 0, 0, 0.2); min-width: 0;
      transition: width 0.3s ease, flex 0.3s ease;
    }

    .vp-side-panel.hidden { display: none; }

    .hud-overlay {
      position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
      pointer-events: none; z-index: 10;
    }

    .target-box {
      width: 42px; height: 42px; position: relative;
      box-shadow: 0 0 0 100vmax rgba(2, 6, 23, 0.6);
      border-radius: 12px; transition: transform 0.1s;
    }
    .target-box::before {
      content: ""; position: absolute; inset: -1px;
      border: 2px solid rgba(255, 255, 255, 0.9); border-radius: 12px;
    }
    .target-box.flash { transform: scale(0.95); }
    .target-box.flash::before { border-color: var(--primary); box-shadow: 0 0 25px var(--primary); }

    .roi-box {
      width: 60px;
      height: 80%;
      position: relative;
      border: 2px dashed rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      display: flex; justify-content: center;
      box-shadow: 0 0 0 100vmax rgba(0,0,0,0.4);
    }
    .roi-label {
        background: rgba(0,0,0,0.6); color: #fff; font-size: 0.6rem; padding: 2px 6px;
        border-radius: 4px; position: absolute; top: -22px; font-weight: 700;
        white-space: nowrap;
    }

    .crosshair { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; opacity: 0.8; }
    .ch-c { width: 4px; height: 4px; background: #fff; border-radius: 50%; box-shadow: 0 0 2px #000; }

    .vp-header {
      font-size: 0.7rem; font-weight: 800; color: #60a5fa;
      text-transform: uppercase; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;
    }

    .advice-item {
      background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px; padding: 12px; margin-bottom: 10px; animation: slideIn 0.3s ease;
    }
    .adv-icon-row { display: flex; align-items: center; gap: 8px; font-size: 0.8rem; font-weight: 700; color: #fff; margin-bottom: 4px; }
    .adv-detail { font-size: 0.7rem; color: var(--text-muted); margin-left: 2px; }

    .placeholder-state {
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      height: 100%; opacity: 0.35; text-align: center; gap: 10px; color: #94a3b8;
    }

    @keyframes slideIn { from { opacity: 0; transform: translateX(10px); } to { opacity: 1; transform: translateX(0); } }

    .panel {
      flex: 1; background: var(--bg-body); display: flex; flex-direction: column;
      overflow: hidden; padding-top: var(--gap-layout); padding-bottom: 0;
      min-height: 0;
    }

    .panel-content {
      padding: 0 20px; display: flex; flex-direction: column; gap: var(--gap-layout);
      margin: 0 auto; width: 100%; height: 100%; min-height: 0;
      overflow-x: hidden; overflow-y: auto; -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain; padding-bottom: 70px;
    }
    .panel-content::-webkit-scrollbar{ width:0; height:0; }

    .result-dashboard {
      display: flex; gap: 12px; justify-content: space-between; align-items: center;
      background: linear-gradient(145deg, #1e293b 0%, #0f172a 100%);
      border: 1px solid var(--border-subtle); border-radius: var(--radius-lg);
      padding: clamp(12px, 2.2vw, 16px) clamp(14px, 2.5vw, 20px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2); flex-shrink: 0; min-width: 0; flex-wrap: wrap;
    }

    .res-left { display: flex; flex-direction: column; gap: 2px; min-width: 0; }
    .res-label { font-size: 0.65rem; color: var(--text-muted); font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }
    .res-value { font-family: var(--font-num); font-size: clamp(2.0rem, 7vw, 2.5rem); font-weight: 800; color: var(--text-main); line-height: 1; }
    .res-badge {
      padding: 8px 14px; border-radius: 10px; font-size: 0.75rem; font-weight: 800;
      background: #334155; color: #fff; letter-spacing: 0.5px; border: 1px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0; white-space: nowrap;
    }
    .status-match .res-value { color: var(--success); }
    .status-match .res-badge { background: rgba(52, 211, 153, 0.2); color: var(--success); border-color: rgba(52, 211, 153, 0.3); }
    .status-close .res-value { color: var(--warn); }
    .status-close .res-badge { background: rgba(251, 191, 36, 0.2); color: var(--warn); border-color: rgba(251, 191, 36, 0.3); }
    .status-diff .res-value { color: var(--danger); }
    .status-diff .res-badge { background: rgba(248, 113, 113, 0.2); color: var(--danger); border-color: rgba(248, 113, 113, 0.3); }

    .cards-container {
      display: grid; grid-template-columns: 1fr 1fr; gap: clamp(10px, 2.4vw, 16px);
      flex-shrink: 1; min-height: 0;
    }

    .data-card {
      background: var(--bg-card); border: 1px solid var(--border-subtle); border-radius: var(--radius-lg);
      padding: clamp(10px, 2.2vw, 12px); display: flex; flex-direction: column; gap: 10px; transition: 0.3s; min-width: 0;
    }

    .card-top { display: flex; justify-content: space-between; align-items: center; }
    .card-title { font-size: 0.75rem; font-weight: 800; color: var(--text-muted); display: flex; align-items: center; gap: 6px; }
    .color-dot { width: 28px; height: 28px; border-radius: 8px; background: #334155; border: 1px solid rgba(255, 255, 255, 0.15); transition: 0.3s; flex-shrink: 0; }

    .lab-row { display: flex; justify-content: space-between; background: rgba(15, 23, 42, 0.5); border-radius: 8px; padding: 6px; border: 1px solid rgba(255, 255, 255, 0.05); }
    .l-item { flex: 1; text-align: center; border-right: 1px solid rgba(255, 255, 255, 0.1); min-width: 0; }
    .l-item:last-child { border: none; }
    .l-lbl { font-size: 0.55rem; color: #64748b; font-weight: 700; margin-bottom: 2px; }
    .l-val { font-family: var(--font-num); font-size: 0.9rem; font-weight: 700; color: #fff; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    .btn-act {
      width: 100%; padding: 12px; border-radius: 10px; border: none; background: rgba(255, 255, 255, 0.05);
      color: #fff; font-size: 0.75rem; font-weight: 700; cursor: pointer; display: flex; align-items: center; justify-content: center;
      gap: 8px; transition: 0.2s; border: 1px solid transparent; font-size: clamp(0.70rem, 2.8vw, 0.75rem);
      padding: clamp(10px, 3.2vw, 12px);
    }
    .btn-act:active { transform: scale(0.96); }
    .btn-act:disabled { opacity: 0.55; cursor: not-allowed; }

    .data-card.active-ref { border-color: var(--primary); background: linear-gradient(165deg, rgba(59, 130, 246, 0.15), #1e293b 90%); }
    .data-card.active-ref .card-title { color: var(--primary); }
    .data-card.active-ref .btn-act { background: var(--primary); color: #fff; box-shadow: 0 4px 15px var(--primary-glow); }
    .data-card.active-sam { border-color: #fff; background: linear-gradient(165deg, rgba(255, 255, 255, 0.1), #1e293b 90%); }
    .data-card.active-sam .card-title { color: #fff; }
    .data-card.active-sam .btn-act { background: #fff; color: #0f172a; box-shadow: 0 4px 15px rgba(255, 255, 255, 0.2); }

    .viz-section {
      display: flex; gap: 12px; height: var(--viz-h); flex-shrink: 1; min-height: 0;
    }
    .graph-box { flex: 1; background: #020617; border: 1px solid var(--border-subtle); border-radius: var(--radius-lg); position: relative; overflow: hidden; min-width: 0; }

    .plot-legend { position: absolute; top: 10px; left: 10px; z-index: 10; display: flex; gap: 8px; pointer-events: none; }
    .legend-item { font-size: 0.6rem; color: #fff; font-weight: 700; display: flex; align-items: center; gap: 5px; background: rgba(15, 23, 42, 0.7); padding: 3px 8px; border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.1); backdrop-filter: blur(4px); }
    .dot-icon { width: 6px; height: 6px; border-radius: 50%; }
    .di-ref { background: var(--primary); box-shadow: 0 0 5px var(--primary); }
    .di-sam { background: var(--sample); }

    .axis-lbl { position: absolute; font-size: 0.55rem; font-weight: 800; color: rgba(255, 255, 255, 0.6); pointer-events: none; text-shadow: 0 0 4px #000; }
    .ax-t { top: 6px; left: 50%; transform: translateX(-50%); }
    .ax-b { bottom: 6px; left: 50%; transform: translateX(-50%); }
    .ax-l { left: 6px; top: 50%; transform: translateY(-50%) rotate(-90deg); }
    .ax-r { right: 6px; top: 50%; transform: translateY(-50%) rotate(90deg); }

    .l-bar-box { width: 40px; background: var(--bg-card); border: 1px solid var(--border-subtle); border-radius: 50px; display: flex; flex-direction: column; align-items: center; padding: 12px 0; position: relative; flex-shrink: 0; }
    .l-track { width: 6px; flex: 1; background: linear-gradient(to top, #020617, #fff); border-radius: 4px; position: relative; margin: 6px 0; }
    .l-mark { position: absolute; left: 50%; transform: translate(-50%, 50%); width: 14px; height: 14px; border-radius: 50%; border: 3px solid var(--bg-card); opacity: 0; transition: bottom 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
    .l-mark.ref { background: var(--primary); z-index: 1; }
    .l-mark.sam { background: #fff; z-index: 2; width: 12px; height: 12px; border-width: 2px; }
    .l-mark.visible { opacity: 1; }

    canvas { display: block; }
    #proc-canvas { display: none; }

    .guidance-hud{
      position:absolute; left: calc(10px + env(safe-area-inset-left)); bottom: calc(10px + env(safe-area-inset-bottom));
      z-index: 25; pointer-events: none; display:flex; justify-content: flex-start; gap: 8px;
      align-items: center; padding: 6px 8px; border-radius: 14px; background: rgba(2,6,23,.28);
      border: 1px solid rgba(255,255,255,.12); backdrop-filter: blur(8px); box-shadow: 0 10px 30px rgba(0,0,0,.18);
      width: fit-content; max-width: calc(100% - 20px);
    }
    .guidance-hud.hidden{ opacity: 0; transform: translateY(-6px); transition: opacity .18s ease, transform .18s ease; }
    .guidance-hud:not(.hidden){ opacity: 1; transform: translateY(0); transition: opacity .18s ease, transform .18s ease; }
    .gauge{ width: 54px; display:flex; flex-direction: column; align-items:center; gap: 4px; }
    .g-lbl{ font-family: var(--font-num); font-size: .52rem; font-weight: 900; letter-spacing: .08em; color: rgba(255,255,255,.78); text-transform: uppercase; line-height: 1; }
    .g-circle{ --p: 0; --c: rgba(251,191,36,.95); width: 34px; height: 34px; border-radius: 50%; position: relative; background: conic-gradient(var(--c) calc(var(--p) * 1%), rgba(255,255,255,.10) 0); display:flex; align-items:center; justify-content:center; }
    .g-circle::after{ content:""; position:absolute; inset: 3px; border-radius: 50%; background: rgba(2,6,23,.55); border: 1px solid rgba(255,255,255,.10); box-shadow: inset 0 0 0 1px rgba(0,0,0,.25); }
    .g-circle i{ position: relative; z-index: 2; width: 14px !important; height: 14px !important; color: rgba(255,255,255,.92); }
    .g-good .g-circle{ --c: rgba(52,211,153,.95); }
    .g-mid  .g-circle{ --c: rgba(251,191,36,.95); }
    .g-bad  .g-circle{ --c: rgba(248,113,113,.95); }
    .g-na .g-circle{ --p: 0; background: radial-gradient(circle at center, rgba(255,255,255,.10), rgba(255,255,255,.06)); }
    .g-na .g-lbl{ opacity: .55; }

    .app-frame.compact{ --frame-gap: clamp(12px, 4.6vw, 34px); --gap-layout: 12px; --radius-lg: 16px; }
    .app-frame.compact header{ padding-left: 14px; padding-right: 14px; }
    .app-frame.compact .panel-content{ padding-left: 14px; padding-right: 14px; gap: var(--gap-layout); }
    .app-frame.compact .result-dashboard{ padding: 12px 14px; gap: 10px; }
    .app-frame.compact .res-value{ font-size: clamp(1.55rem, 6.2vw, 2.15rem); }
    .app-frame.compact .res-badge{ padding: 7px 12px; font-size: 0.72rem; }
    .app-frame.compact .btn-icon-dash{ width: 36px; height: 36px; }
    .app-frame.compact .data-card{ padding: 10px; border-radius: 16px; }
    .app-frame.compact .card-title{ font-size: 0.72rem; }
    .app-frame.compact .lab-row{ padding: 6px; }
    .app-frame.compact .l-val{ font-size: 0.84rem; }
    .app-frame.compact .btn-act{ padding: 10px; font-size: 0.72rem; }
    .app-frame.compact .viz-section{ height: calc(var(--viz-h) - 14px); }

    @media (max-width: 360px){
      .header-controls{ flex-wrap: wrap; justify-content: flex-end; }
      .algo-selector{ max-width: 128px; padding: 8px 10px; font-size: 0.72rem; }
      .dash-right{ width: 100%; justify-content: space-between; gap: 10px; }
      .btn-icon-dash{ width: 36px; height: 36px; }
    }

    .tab-bar {
        position: absolute; bottom: 0; left: 0; right: 0; height: var(--tab-h);
        background: rgba(15, 23, 42, 0.9); backdrop-filter: blur(10px);
        border-top: 1px solid var(--border-subtle); display: flex;
        justify-content: space-around; align-items: center; z-index: 100;
        padding-bottom: env(safe-area-inset-bottom);
    }
    .tab-item {
        flex: 1; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;
        color: var(--text-muted); gap: 4px; cursor: pointer; transition: 0.2s;
    }
    .tab-item.active { color: var(--primary); }
    .tab-lbl { font-size: 0.65rem; font-weight: 700; }
    .tab-item i { transition: transform 0.2s; }
    .tab-item.active i { transform: translateY(-2px); }

    .display-none { display: none !important; }

    /* --- GLUE GAP DASHBOARD CSS (NEW) --- */
    .glue-dashboard {
      display: flex; flex-direction: column; gap: 12px; height: 100%;
    }

    /* 1. Summary Row */
    .glue-stats-row {
      display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;
      flex-shrink: 0;
    }
    .g-stat-card {
      background: var(--bg-card); border: 1px solid var(--border-subtle);
      border-radius: 12px; padding: 8px 4px; text-align: center;
      display: flex; flex-direction: column; justify-content: center;
    }
    .gs-lbl { font-size: 0.55rem; color: var(--text-muted); font-weight: 700; text-transform: uppercase; margin-bottom: 2px; }
    .gs-val { font-family: var(--font-num); font-size: 1.1rem; font-weight: 800; color: #fff; line-height: 1; }
    .gs-val.warn { color: var(--warn); }
    .gs-val.ok { color: var(--success); }

    /* 2. Chart Section */
    .glue-chart-container {
      height: 100px; background: var(--bg-card); border: 1px solid var(--border-subtle);
      border-radius: 12px; position: relative; overflow: hidden; flex-shrink: 0;
      padding: 10px; display: flex; align-items: flex-end;
    }
    #glue-profile-canvas { width: 100%; height: 100%; display: block; }
    .chart-label { position: absolute; top: 6px; left: 10px; font-size: 0.6rem; font-weight: 700; color: rgba(255,255,255,0.5); }

    /* 3. Table Section */
    .glue-table-wrapper {
      flex: 1; background: var(--bg-card); border: 1px solid var(--border-subtle);
      border-radius: 12px; overflow: hidden; display: flex; flex-direction: column;
      min-height: 0; /* Important for scroll */
    }
    .glue-table-header {
      display: flex; padding: 8px 12px; background: rgba(0,0,0,0.2);
      border-bottom: 1px solid var(--border-subtle);
      font-size: 0.6rem; font-weight: 700; color: var(--text-muted); text-transform: uppercase;
    }
    .gt-col { flex: 1; text-align: center; }
    .gt-col.idx { flex: 0 0 40px; text-align: left; }
    .gt-col.sts { flex: 0 0 60px; text-align: right; }

    .glue-table-body {
      flex: 1; overflow-y: auto; padding: 0 4px;
    }
    .gt-row {
      display: flex; padding: 8px 8px; border-bottom: 1px solid rgba(255,255,255,0.03);
      align-items: center; animation: fadeIn 0.2s;
    }
    .gt-row:last-child { border-bottom: none; }
    .gt-cell { flex: 1; text-align: center; font-family: var(--font-num); font-size: 0.8rem; font-weight: 600; color: #fff; }
    .gt-cell.idx { flex: 0 0 40px; text-align: left; color: var(--text-muted); font-size: 0.7rem; }
    .gt-cell.sts { flex: 0 0 60px; text-align: right; }

    .sts-badge {
      font-size: 0.6rem; padding: 2px 6px; border-radius: 4px; font-weight: 800; display: inline-block;
    }
    .sts-ok { background: rgba(52, 211, 153, 0.15); color: var(--success); border: 1px solid rgba(52, 211, 153, 0.3); }
    .sts-bad { background: rgba(248, 113, 113, 0.15); color: var(--danger); border: 1px solid rgba(248, 113, 113, 0.3); }
    .sts-na { background: rgba(255, 255, 255, 0.05); color: var(--text-muted); border: 1px solid rgba(255, 255, 255, 0.1); }

    @keyframes fadeIn { from{opacity:0;} to{opacity:1;} }
  </style>
</head>

<body>
  <div class="app-frame">
    <header>
      <div class="brand"><i data-lucide="scan-face"></i> PackEx <span>Mobility</span></div>
      <div class="header-controls">
        <div id="ctl-color-algo">
            <select id="algo-select" class="algo-selector" onchange="changeMode(this.value)">
              <option value="2000">DE 2000</option>
              <option value="94">DE 94</option>
              <option value="76">DE 76</option>
            </select>
        </div>
        <button class="btn-icon-header" id="btn-torch" onclick="toggleTorchHold()" title="Torch">
          <i data-lucide="flashlight" style="width: 18px;"></i>
        </button>
      </div>
    </header>

    <div class="viewport">
      <div class="vp-camera" id="vp-camera">
        <video id="webcam" autoplay playsinline muted></video>
        <img id="ghost-overlay" class="ghost-overlay" src="" alt="Ghost Reference" />
        <canvas id="sheet-canvas"></canvas>

        <div id="guidanceHud" class="guidance-hud hidden" aria-label="Capture guidance">
          <div class="gauge" id="gAngleGauge" title="Angle / Tilt">
            <div class="g-circle" id="gAngleCircle"><i data-lucide="rotate-3d"></i></div>
            <div class="g-lbl">ANGLE</div>
          </div>
          <div class="gauge" id="gGlareGauge" title="Glare / Reflection">
            <div class="g-circle" id="gGlareCircle"><i data-lucide="sun"></i></div>
            <div class="g-lbl">GLARE</div>
          </div>
        </div>

        <div class="hud-overlay">
          <div id="target-box" class="target-box">
            <div class="crosshair"><div class="ch-c"></div></div>
          </div>
          <div id="sheet-roi-box" class="roi-box display-none">
             <div class="roi-label">SCAN ZONE</div>
          </div>
        </div>
      </div>

      <div class="vp-side-panel" id="vp-side-panel">
        <div id="side-colex">
          <div class="vp-header"><i data-lucide="bot" style="width: 14px;"></i> AI ASSIST</div>
          <div id="advice-content"></div>
          <div id="advice-placeholder" class="placeholder-state">
            <i data-lucide="scan" style="width: 28px; opacity: 0.55;"></i>
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="panel-content">
        
        <div id="panel-colex" style="display:flex; flex-direction:column; gap:var(--gap-layout);">
          <div id="result-dashboard" class="result-dashboard">
            <div class="res-left">
              <div class="res-label">Delta E <span id="algo-lbl">2000</span></div>
              <div class="res-value" id="delta-val">--</div>
            </div>
            <div class="dash-right">
              <div class="res-badge" id="delta-msg">READY</div>
              <button class="btn-icon-header btn-icon-dash" onclick="resetAll()" title="Reset">
                <i data-lucide="rotate-cw" style="width: 18px;"></i>
              </button>
            </div>
          </div>

          <div class="cards-container">
            <div class="data-card" id="card-ref">
              <div class="card-top">
                <div class="card-title"><i data-lucide="crosshair" style="width: 14px;"></i> REF</div>
                <div class="color-dot" id="preview-ref"></div>
              </div>
              <div class="lab-row">
                <div class="l-item"><div class="l-lbl">L</div><div class="l-val" id="ref-l">-</div></div>
                <div class="l-item"><div class="l-lbl">a</div><div class="l-val" id="ref-a">-</div></div>
                <div class="l-item"><div class="l-lbl">b</div><div class="l-val" id="ref-b">-</div></div>
              </div>
              <button class="btn-act" id="btn-lock-ref" onclick="lockRef()">
                <i data-lucide="fingerprint" style="width: 16px;"></i> CAPTURE
              </button>
            </div>

            <div class="data-card" id="card-sam">
              <div class="card-top">
                <div class="card-title"><i data-lucide="zap" style="width: 14px;"></i> SAMPLE</div>
                <div class="color-dot" id="preview-sam"></div>
              </div>
              <div class="lab-row">
                <div class="l-item"><div class="l-lbl">L</div><div class="l-val" id="sam-l">-</div></div>
                <div class="l-item"><div class="l-lbl">a</div><div class="l-val" id="sam-a">-</div></div>
                <div class="l-item"><div class="l-lbl">b</div><div class="l-val" id="sam-b">-</div></div>
              </div>
              <button class="btn-act" id="btn-lock-sam" onclick="lockSam()">
                <i data-lucide="scan-line" style="width: 16px;"></i> CAPTURE
              </button>
            </div>
          </div>

          <div class="viz-section">
            <div class="graph-box">
              <div class="plot-legend">
                <div class="legend-item"><div class="dot-icon di-ref"></div> REF</div>
                <div class="legend-item"><div class="dot-icon di-sam"></div> SAM</div>
              </div>
              <div class="axis-lbl ax-t">+b Yel</div>
              <div class="axis-lbl ax-b">-b Blu</div>
              <div class="axis-lbl ax-l">-a Grn</div>
              <div class="axis-lbl ax-r">+a Red</div>
              <canvas id="ab-plot"></canvas>
            </div>
            <div class="l-bar-box">
              <div style="font-size: 0.5rem; color: #64748b; font-weight: 700;">L*</div>
              <div class="l-track">
                <div id="marker-ref" class="l-mark ref"></div>
                <div id="marker-sam" class="l-mark sam"></div>
              </div>
            </div>
          </div>
        </div>

        <div id="panel-gluegap" class="display-none" style="height:100%; overflow:hidden;">
          <div class="glue-dashboard">
            
            <div class="glue-stats-row">
              <div class="g-stat-card">
                <div class="gs-lbl">LAYERS</div>
                <div class="gs-val" id="sh-count">0</div>
              </div>
              <div class="g-stat-card">
                <div class="gs-lbl">FOUND</div>
                <div class="gs-val ok" id="sh-found">0</div>
              </div>
              <div class="g-stat-card">
                <div class="gs-lbl">MISSING</div>
                <div class="gs-val warn" id="sh-missing">0</div>
              </div>
              <div class="g-stat-card">
                <div class="gs-lbl">AVG (px)</div>
                <div class="gs-val" id="sh-avg">-</div>
              </div>
            </div>

            <div class="glue-chart-container">
              <div class="chart-label">WIDTH PROFILE</div>
              <canvas id="glue-profile-canvas"></canvas>
            </div>

            <div class="glue-table-wrapper">
              <div class="glue-table-header">
                <div class="gt-col idx">#</div>
                <div class="gt-col">Position</div>
                <div class="gt-col">Width</div>
                <div class="gt-col sts">Status</div>
              </div>
              <div class="glue-table-body" id="glue-table-list">
                <div style="padding:20px; text-align:center; color:#475569; font-size:0.75rem;">
                  No Data
                </div>
              </div>
            </div>

            <button class="btn-act" id="btn-sheet-cap" onclick="toggleSheetCapture()" 
                    style="background:var(--primary); box-shadow:0 4px 15px var(--primary-glow); flex-shrink:0;">
              <i data-lucide="camera" style="width: 16px;"></i> CAPTURE / FREEZE
            </button>

          </div>
        </div>

      </div>
    </div>

    <div class="tab-bar">
      <div class="tab-item active" id="tab-colex" onclick="switchTab('colex')">
        <i data-lucide="palette"></i>
        <span class="tab-lbl">COLEX</span>
      </div>
      <div class="tab-item" id="tab-gluegap" onclick="switchTab('gluegap')">
        <i data-lucide="layers"></i>
        <span class="tab-lbl">GLUE GAP</span>
      </div>
    </div>

  </div>

  <canvas id="proc-canvas" width="100" height="100"></canvas>

  <script>
    lucide.createIcons();

    // --- GLOBALS ---
    const video = document.getElementById("webcam");
    const procCanvas = document.getElementById("proc-canvas");
    const procCtx = procCanvas.getContext("2d", { willReadFrequently: true });
    const plotCanvas = document.getElementById("ab-plot");
    const plotCtx = plotCanvas.getContext("2d", { willReadFrequently: true });
    
    // Sheet Globals
    const sheetCanvas = document.getElementById("sheet-canvas");
    const sheetCtx = sheetCanvas.getContext("2d");
    const glueProfileCanvas = document.getElementById("glue-profile-canvas");
    const glueProfileCtx = glueProfileCanvas.getContext("2d");

    const ghostOverlay = document.getElementById("ghost-overlay");
    const guidanceHud = document.getElementById("guidanceHud");
    const gAngleGauge = document.getElementById("gAngleGauge");
    const gGlareGauge = document.getElementById("gGlareGauge");
    const gAngleCircle = document.getElementById("gAngleCircle");
    const gGlareCircle = document.getElementById("gGlareCircle");

    let activeTab = 'colex';
    let isProcessing = false;
    let liveLab = null;
    let liveRGB = null;
    let savedRefLab = null, savedSamLab = null;
    let bgImageData = null;
    let deltaMode = "2000";
    let videoTrack = null;
    let torchSupported = false;
    let isTorchBusy = false;
    let isTorchOn = false;
    let cameraLocked = false;
    let lastOri = { beta: null, gamma: null, alpha: null };
    let refMetrics = null;
    let liveMetrics = null;

    let sheetFrozen = false;
    let sheetResults = [];

    // --- LAYOUT ---
    function setCompactMode() {
      const frame = document.querySelector(".app-frame");
      if (!frame) return;
      const vvH = window.visualViewport ? window.visualViewport.height : window.innerHeight;
      const vvW = window.visualViewport ? window.visualViewport.width : window.innerWidth;
      const compact = (vvW <= 390) || (vvH <= 740);
      frame.classList.toggle("compact", compact);
    }
    function setRealAppHeight() {
      const h = window.visualViewport ? window.visualViewport.height : window.innerHeight;
      document.documentElement.style.setProperty("--app-h", `${Math.round(h)}px`);
      setCompactMode();
      if (typeof applyAutoFitLayout === "function") requestAnimationFrame(applyAutoFitLayout);
    }
    setRealAppHeight();
    window.addEventListener("resize", setRealAppHeight);
    window.addEventListener("orientationchange", setRealAppHeight);
    if (window.visualViewport) {
      window.visualViewport.addEventListener("resize", setRealAppHeight);
      window.visualViewport.addEventListener("scroll", setRealAppHeight);
    }

    // --- TABS ---
    function switchTab(mode) {
      activeTab = mode;
      document.querySelectorAll('.tab-item').forEach(el => el.classList.remove('active'));
      document.getElementById(`tab-${mode}`).classList.add('active');

      if (mode === 'colex') {
        document.getElementById('ctl-color-algo').classList.remove('display-none');
        document.getElementById('vp-side-panel').classList.remove('hidden');
        document.getElementById('vp-camera').classList.remove('full-width');

        document.getElementById('panel-colex').style.display = 'flex';
        document.getElementById('target-box').classList.remove('display-none');

        document.getElementById('panel-gluegap').classList.add('display-none');
        document.getElementById('sheet-roi-box').classList.add('display-none');

        sheetFrozen = false;
        sheetCtx.clearRect(0,0,sheetCanvas.width, sheetCanvas.height);

      } else {
        // Mode: gluegap
        document.getElementById('ctl-color-algo').classList.add('display-none');
        document.getElementById('vp-side-panel').classList.add('hidden');
        document.getElementById('vp-camera').classList.add('full-width');

        document.getElementById('panel-colex').style.display = 'none';
        document.getElementById('target-box').classList.add('display-none');

        document.getElementById('panel-gluegap').classList.remove('display-none');
        document.getElementById('panel-gluegap').style.display = 'flex';

        document.getElementById('sheet-roi-box').classList.remove('display-none');

        resetSheetUI();
      }
      lucide.createIcons();
    }

    // --- CAMERA ---
    async function initCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } },
        });
        video.srcObject = stream;
        videoTrack = stream.getVideoTracks?.()[0] || null;
        try {
          const caps = videoTrack?.getCapabilities?.();
          torchSupported = !!caps?.torch;
        } catch (e) { torchSupported = false; }
        updateTorchUI();
        video.onloadedmetadata = () => {
          resizeGraph();
          sheetCanvas.width = video.videoWidth;
          sheetCanvas.height = video.videoHeight;
          window.addEventListener("resize", resizeGraph);
          isProcessing = true;
          requestAnimationFrame(loop);
        };
      } catch (err) { alert("Camera Error: " + err); }
    }

    function resizeGraph() {
      const container = document.querySelector(".graph-box");
      if (container) {
        plotCanvas.width = container.offsetWidth;
        plotCanvas.height = container.offsetHeight;
        renderColorMap();
        drawABGraph();
      }
      // Also resize glue chart if visible
      if (glueProfileCanvas.offsetParent !== null) {
          glueProfileCanvas.width = glueProfileCanvas.offsetWidth;
          glueProfileCanvas.height = glueProfileCanvas.offsetHeight;
      }
    }

    // --- LOOP ---
    function loop() {
      if (!isProcessing) return;

      if (activeTab === 'colex') {
        readOneSample();
        drawABGraph();
        liveMetrics = readLiveQuality();
        if (refMetrics && liveMetrics) updateGuidanceHud(refMetrics, liveMetrics);
        else showGuidance(false);
      } else {
        // Glue Gap mode
        processSheetFrame();
        showGuidance(false);
      }
      requestAnimationFrame(loop);
    }

    // =========================================================
    // --- UPDATED GLUE GAP LOGIC (Local Contrast & Waveform) ---
    // =========================================================

    function processSheetFrame() {
      if (sheetFrozen) return;
      if (video.readyState !== video.HAVE_ENOUGH_DATA) return;

      const w = video.videoWidth;
      const h = video.videoHeight;

      // Setup Canvas
      if(sheetCanvas.width !== w || sheetCanvas.height !== h) {
        sheetCanvas.width = w; sheetCanvas.height = h;
      }
      
      // ROI Setting (แถบกลางภาพ)
      const roiW = 60; 
      const roiX = (w - roiW) / 2;

      // ดึงภาพเฉพาะส่วน ROI มาวิเคราะห์
      if(procCanvas.width !== roiW || procCanvas.height !== h) {
        procCanvas.width = roiW; procCanvas.height = h;
      }
      procCtx.drawImage(video, roiX, 0, roiW, h, 0, 0, roiW, h);
      const data = procCtx.getImageData(0, 0, roiW, h).data;

      // 1. สร้าง Vertical Profile (แปลงภาพเป็นกราฟความเข้มแสงแนวตั้ง)
      // ยิ่งค่ามาก = ยิ่งมืด (Inverted Luma) เพื่อให้ร่องกาวเป็นยอดกราฟ (Peak)
      const profile = new Float32Array(h);
      for(let y = 0; y < h; y++) {
        let sum = 0;
        for(let x = 0; x < roiW; x++) {
          const i = (y * roiW + x) * 4;
          // สูตร Luma: 0.299R + 0.587G + 0.114B
          const luma = (data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114);
          sum += luma;
        }
        // Invert: 255 - avg (เพื่อให้จุดมืดมีค่าสูง)
        profile[y] = 255 - (sum / roiW);
      }

      // 2. Smooth Profile (ลด Noise)
      const smoothed = smoothArray(profile, 4); // รัศมี Smooth 4px

      // 3. Find Peaks (หาจุดที่เป็นร่องกาว)
      // ใช้ Prominence: จุดยอดต้องสูงกว่าพื้นที่รอบข้างอย่างน้อย 15 หน่วย
      const minProminence = 15; 
      const minDist = h * 0.02; // ระยะห่างขั้นต่ำระหว่างร่อง (2% ของความสูง)
      
      const peaks = findPeaks(smoothed, minProminence, minDist);

      // --- RENDERING & MEASURING ---
      sheetCtx.clearRect(0,0,w,h);
      
      const results = [];
      let totalW = 0;
      let foundCount = 0;

      peaks.forEach((peak, i) => {
        // Measure Width (วัดความกว้างแนวนอน ณ จุด Y ที่เจอ)
        // ส่งข้อมูลภาพเต็มความกว้าง (video) ไปวัดโดยใช้ ROI เดิม เพื่อความเร็ว
        const measured = measureGrooveWidthAdvanced(data, roiW, peak.index);
        
        let status = "NO_READ";
        let widthVal = 0;

        if (measured.quality > 0.5 && measured.width > 2) {
             widthVal = measured.width;
             status = "OK";
             totalW += widthVal;
             foundCount++;
        }

        results.push({ layer: i+1, y: peak.index, w: widthVal, status });

        // Draw Visuals
        const gapY = peak.index;
        const boxW = 100;
        const boxH = 18; 
        const boxX = (w/2) - (boxW/2);
        const boxY = gapY - (boxH/2);

        // Line
        sheetCtx.beginPath();
        sheetCtx.moveTo(0, gapY);
        sheetCtx.lineTo(w, gapY);
        sheetCtx.strokeStyle = (status === 'OK') ? "rgba(0, 255, 65, 0.6)" : "rgba(248, 113, 113, 0.5)";
        sheetCtx.lineWidth = 1;
        sheetCtx.stroke();

        // Label
        sheetCtx.fillStyle = (status === 'OK') ? "rgba(0, 0, 0, 0.6)" : "rgba(100, 0, 0, 0.6)";
        sheetCtx.strokeStyle = (status === 'OK') ? "#00ff41" : "#f87171";
        sheetCtx.lineWidth = 1;
        sheetCtx.fillRect(boxX, boxY, boxW, boxH);
        sheetCtx.strokeRect(boxX, boxY, boxW, boxH);

        sheetCtx.fillStyle = "#fff";
        sheetCtx.font = "bold 11px 'Inter'";
        sheetCtx.textBaseline = "middle";
        sheetCtx.textAlign = "center";
        const txt = (status==='OK') ? `W: ${widthVal.toFixed(1)} px` : `Layer ${i+1}`;
        sheetCtx.fillText(txt, w/2, gapY);
      });

      // Update Stats
      const expected = peaks.length; // หรือกำหนดตายตัวถ้าทราบจำนวนชั้น
      const missing = Math.max(0, expected - foundCount);
      const avg = foundCount > 0 ? (totalW / foundCount) : 0;

      document.getElementById('sh-count').innerText = String(expected);
      document.getElementById('sh-found').innerText = String(foundCount);
      document.getElementById('sh-missing').innerText = String(missing);
      document.getElementById('sh-avg').innerText = (foundCount > 0 ? avg.toFixed(1) : "-");

      // ส่ง smoothed profile ไปวาดกราฟ Waveform
      renderGlueChart(results, smoothed, 0, 255);
      renderGlueTable(results);

      sheetResults = results;
    }

    // --- HELPER: Smooth Array (Simple Box Blur) ---
    function smoothArray(arr, radius) {
      const res = new Float32Array(arr.length);
      for(let i = 0; i < arr.length; i++) {
        let sum = 0;
        let count = 0;
        for(let r = -radius; r <= radius; r++) {
          const idx = i + r;
          if(idx >= 0 && idx < arr.length) {
            sum += arr[idx];
            count++;
          }
        }
        res[i] = sum / count;
      }
      return res;
    }

    // --- HELPER: Peak Detection (Local Maxima) ---
    function findPeaks(arr, prominence, minDist) {
      // 1. Find Local Maxima
      const candidates = [];
      for(let i = 1; i < arr.length - 1; i++) {
        if(arr[i] > arr[i-1] && arr[i] > arr[i+1]) {
           candidates.push({ index: i, value: arr[i] });
        }
      }

      // 2. Filter by "Prominence"
      const finalPeaks = [];
      candidates.forEach(cand => {
         // หาค่าต่ำสุดในช่วง local (ซ้ายขวา 20px)
         let localMin = 255;
         const range = 20;
         for(let k = -range; k <= range; k++) {
            const idx = cand.index + k;
            if(idx>=0 && idx<arr.length) {
               if(arr[idx] < localMin) localMin = arr[idx];
            }
         }
         
         if((cand.value - localMin) > prominence) {
            finalPeaks.push(cand);
         }
      });

      // 3. Filter by Distance
      finalPeaks.sort((a,b) => b.value - a.value);
      
      const result = [];
      finalPeaks.forEach(p => {
         const tooClose = result.some(existing => Math.abs(existing.index - p.index) < minDist);
         if(!tooClose) {
            result.push(p);
         }
      });

      // คืนค่าโดยเรียงตามตำแหน่ง Y (บนลงล่าง)
      return result.sort((a,b) => a.index - b.index);
    }

    // --- HELPER: Measure Groove Width (FWHM Style) ---
    function measureGrooveWidthAdvanced(data, w, centerY) {
       // สร้าง Horizontal Profile ณ จุด centerY
       const rowProfile = new Float32Array(w);
       let maxVal = -999;
       let minVal = 999;
       let maxIndex = 0;

       for(let x = 0; x < w; x++) {
          let sum = 0;
          for(let dy = -1; dy <= 1; dy++) {
             const y = Math.min(Math.max(0, centerY + dy), 1000);
             const idx = (y * w + x) * 4;
             const val = (data[idx]*0.299 + data[idx+1]*0.587 + data[idx+2]*0.114);
             sum += val;
          }
          const avgLuma = sum / 3;
          const valInv = 255 - avgLuma;
          rowProfile[x] = valInv;

          if(valInv > maxVal) { maxVal = valInv; maxIndex = x; }
          if(valInv < minVal) minVal = valInv;
       }

       const contrast = maxVal - minVal;
       if (contrast < 15) return { width: 0, quality: 0 };

       const halfHeight = minVal + (contrast * 0.5);

       let leftX = maxIndex;
       while(leftX > 0 && rowProfile[leftX] > halfHeight) {
          leftX--;
       }

       let rightX = maxIndex;
       while(rightX < w - 1 && rowProfile[rightX] > halfHeight) {
          rightX++;
       }

       const width = rightX - leftX;
       const quality = Math.min(1.0, contrast / 50);

       return { width, quality };
    }

    // --- HELPER: Render Glue Chart (Waveform + Bars) ---
    function renderGlueChart(results, signal, minSig, maxSig) {
      const w = glueProfileCanvas.offsetWidth;
      const h = glueProfileCanvas.offsetHeight;
      if (glueProfileCanvas.width !== w) { glueProfileCanvas.width = w; glueProfileCanvas.height = h; }
      
      glueProfileCtx.clearRect(0, 0, w, h);

      // 1. วาดเส้น Signal Profile (Waveform)
      if(signal && signal.length > 0) {
        glueProfileCtx.beginPath();
        glueProfileCtx.strokeStyle = "rgba(255, 255, 255, 0.3)";
        glueProfileCtx.lineWidth = 1.5;
        
        const range = maxSig - minSig;
        
        for(let i=0; i<signal.length; i++) {
           const val = signal[i];
           // Normalize 0-1
           const norm = (range > 0) ? (val - minSig) / range : 0.5; 
           // Map signal value (strength) to height
           const plotY = h - (norm * h * 0.9) - (h*0.05); 
           const plotX = (i / signal.length) * w;

           if(i===0) glueProfileCtx.moveTo(plotX, plotY);
           else glueProfileCtx.lineTo(plotX, plotY);
        }
        glueProfileCtx.stroke();
      }

      // 2. วาดแท่งผลลัพธ์ (Bars)
      if (!results || results.length === 0) return;

      const barGap = 2;
      const barW = (w / results.length) - barGap;
      const maxW = 50; 
      
      results.forEach((r, i) => {
         const val = r.w;
         const barH = (val / maxW) * (h * 0.6); // ลดความสูงลงหน่อยเพื่อไม่ให้บังกราฟเส้น
         const x = i * (barW + barGap);
         const y = h - barH;
         
         glueProfileCtx.fillStyle = (r.status === 'OK') ? 'rgba(52, 211, 153, 0.8)' : 'rgba(248, 113, 113, 0.8)';
         
         // วาด Bar
         if(r.status !== 'OK') {
             glueProfileCtx.fillRect(x, h - 4, Math.max(1, barW), 4);
         } else {
             glueProfileCtx.fillRect(x, y, Math.max(1, barW), barH);
             
             // เพิ่มตัวเลขบนกราฟแท่ง
             glueProfileCtx.fillStyle = "#fff";
             glueProfileCtx.font = "bold 9px 'Inter'";
             glueProfileCtx.textAlign = "center";
             if(barW > 12) {
                glueProfileCtx.fillText(Math.round(val), x + barW/2, y - 4);
             }
         }
      });
    }

    let frameSkipCounter = 0;
    function renderGlueTable(results) {
       if (!sheetFrozen && frameSkipCounter++ % 10 !== 0) return;

       const list = document.getElementById("glue-table-list");
       if (!results || results.length === 0) {
           list.innerHTML = '<div style="padding:20px; text-align:center; color:#475569; font-size:0.75rem;">No Data</div>';
           return;
       }

       let html = '';
       results.forEach(r => {
           const badgeClass = (r.status === 'OK') ? 'sts-ok' : 'sts-bad';
           const statusTxt = (r.status === 'OK') ? 'PASS' : 'FAIL';
           const widthTxt = (r.status === 'OK') ? Math.round(r.w) : '-';
           
           html += `
             <div class="gt-row">
               <div class="gt-cell idx">${r.layer}</div>
               <div class="gt-cell" style="color:var(--text-muted); font-size:0.7rem;">Y:${Math.round(r.y)}</div>
               <div class="gt-cell" style="color:${r.status==='OK'?'#fff':'var(--danger)'}">${widthTxt}</div>
               <div class="gt-cell sts">
                 <span class="sts-badge ${badgeClass}">${statusTxt}</span>
               </div>
             </div>
           `;
       });
       list.innerHTML = html;
    }

    function toggleSheetCapture() {
      const btn = document.getElementById('btn-sheet-cap');
      if(sheetFrozen) {
        sheetFrozen = false;
        btn.innerHTML = '<i data-lucide="camera" style="width:16px;"></i> CAPTURE / FREEZE';
        btn.style.background = 'var(--primary)';
      } else {
        sheetFrozen = true;
        btn.innerHTML = '<i data-lucide="rotate-ccw" style="width:16px;"></i> RESUME';
        btn.style.background = '#334155';
        // Render one last time to ensure crisp data
        renderGlueTable(sheetResults); 
      }
      lucide.createIcons();
    }

    function resetSheetUI() {
      document.getElementById('sh-count').innerText = "0";
      document.getElementById('sh-found').innerText = "0";
      document.getElementById('sh-missing').innerText = "0";
      document.getElementById('sh-avg').innerText = "-";
      sheetCtx.clearRect(0,0,sheetCanvas.width, sheetCanvas.height);
      sheetResults = [];
      document.getElementById("glue-table-list").innerHTML = '';
      if(glueProfileCtx) glueProfileCtx.clearRect(0,0, glueProfileCanvas.width, glueProfileCanvas.height);
    }

    // --- COLOR HELPERS (UNCHANGED) ---
    function getSmartAverage(arr) {
      if (arr.length === 0) return 0;
      arr.sort((a, b) => a - b);
      const trimAmt = Math.floor(arr.length * 0.25);
      const target = arr.slice(trimAmt, arr.length - trimAmt);
      if (target.length === 0) return arr[Math.floor(arr.length / 2)];
      const sum = target.reduce((a, b) => a + b, 0);
      return Math.round(sum / target.length);
    }
    function readOneSample() {
      if (video.readyState !== video.HAVE_ENOUGH_DATA) return null;
      const W = 100, H = 100;
      if (procCanvas.width !== W) { procCanvas.width=W; procCanvas.height=H; }
      const sx = (video.videoWidth - W) / 2;
      const sy = (video.videoHeight - H) / 2;
      procCtx.drawImage(video, sx, sy, W, H, 0, 0, W, H);
      const frame = procCtx.getImageData(0, 0, W, H);
      const data = frame.data;
      let rList = [], gList = [], bList = [];
      for (let i = 0; i < data.length; i += 20) {
        rList.push(data[i]); gList.push(data[i + 1]); bList.push(data[i + 2]);
      }
      const r = getSmartAverage(rList);
      const g = getSmartAverage(gList);
      const b = getSmartAverage(bList);
      const rgb = `rgb(${r},${g},${b})`;
      const lab = rgbToLab(r, g, b);
      liveRGB = rgb;
      liveLab = lab;
      return { rgb, lab };
    }
    function wait(ms) { return new Promise((r) => setTimeout(r, ms)); }
    async function captureSmartSample() {
      if (isTorchBusy) return null;
      isTorchBusy = true;
      try {
        const frames = 10;
        let sumL = 0, sumA = 0, sumB = 0;
        let lastRGB = "";
        for (let i = 0; i < frames; i++) {
          const sample = readOneSample();
          if (sample) {
            sumL += parseFloat(sample.lab.L);
            sumA += parseFloat(sample.lab.a);
            sumB += parseFloat(sample.lab.b);
            lastRGB = sample.rgb;
          }
          await wait(30);
        }
        return {
          rgb: lastRGB,
          lab: { L: (sumL / frames).toFixed(1), a: (sumA / frames).toFixed(1), b: (sumB / frames).toFixed(1) }
        };
      } finally { isTorchBusy = false; }
    }
    async function toggleCameraLock(lock) {
      if (!videoTrack) return;
      try {
        const capabilities = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
        const constraints = { advanced: [] };
        if (lock) {
          if (capabilities.whiteBalanceMode?.includes('manual')) constraints.advanced.push({ whiteBalanceMode: 'manual' });
          if (capabilities.exposureMode?.includes('manual')) constraints.advanced.push({ exposureMode: 'manual' });
        } else {
          if (capabilities.whiteBalanceMode?.includes('continuous')) constraints.advanced.push({ whiteBalanceMode: 'continuous' });
          if (capabilities.exposureMode?.includes('continuous')) constraints.advanced.push({ exposureMode: 'continuous' });
        }
        if (constraints.advanced.length > 0) {
          await videoTrack.applyConstraints(constraints);
          cameraLocked = lock;
        }
      } catch (e) { console.warn("Camera locking not supported", e); }
    }
    function captureGhostImage() {
      const c = document.createElement("canvas");
      c.width = video.videoWidth; c.height = video.videoHeight;
      c.getContext("2d").drawImage(video, 0, 0);
      return c.toDataURL("image/jpeg", 0.8);
    }

    // --- METRICS ---
    function computeRegionMetrics(imgData, w, h) {
      const d = imgData.data;
      let sumL = 0, over = 0, n = 0, sharp = 0;
      const lumaAt = (i) => (0.2126 * d[i] + 0.7152 * d[i + 1] + 0.0722 * d[i + 2]);
      const lum = new Float32Array(w * h);
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const idx = (y * w + x) * 4;
          const L = lumaAt(idx);
          lum[y * w + x] = L;
          sumL += L; n++;
          if (d[idx] >= 245 && d[idx + 1] >= 245 && d[idx + 2] >= 245) over++;
        }
      }
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const here = lum[y * w + x];
          if (x + 1 < w) sharp += Math.abs(here - lum[y * w + (x + 1)]);
          if (y + 1 < h) sharp += Math.abs(here - lum[(y + 1) * w + x]);
        }
      }
      return { meanLuma: sumL / Math.max(1, n), sharpness: sharp, overPct: over / Math.max(1, n) };
    }
    function readLiveQuality() {
      if (video.readyState !== video.HAVE_ENOUGH_DATA) return null;
      const w = 50, h = 50;
      if(procCanvas.width !== w) { procCanvas.width = w; procCanvas.height = h; }
      const sx = (video.videoWidth - w) / 2;
      const sy = (video.videoHeight - h) / 2;
      procCtx.drawImage(video, sx, sy, w, h, 0, 0, w, h);
      const m = computeRegionMetrics(procCtx.getImageData(0,0,w,h), w, h);
      return { ...m, beta: lastOri?.beta ?? null, gamma: lastOri?.gamma ?? null };
    }
    const clamp01 = (x) => Math.max(0, Math.min(1, x));
    function showGuidance(visible) {
      if (!guidanceHud) return;
      guidanceHud.classList.toggle("hidden", !visible);
    }
    function setGaugeState(gaugeEl, circleEl, score01, stateClass) {
      if (!gaugeEl || !circleEl) return;
      gaugeEl.classList.remove("g-good", "g-mid", "g-bad", "g-na");
      if (stateClass) gaugeEl.classList.add(stateClass);
      const p = Math.round(Math.max(0, Math.min(1, score01)) * 100);
      circleEl.style.setProperty("--p", p);
    }
    function updateGuidanceHud(ref, cur) {
      if (!ref || !cur) { showGuidance(false); return; }
      showGuidance(true);
      let tiltDiff = null;
      if (typeof ref.beta === "number" && typeof ref.gamma === "number" && typeof cur.beta === "number" && typeof cur.gamma === "number") {
        const db = Math.abs(cur.beta - ref.beta);
        const dg = Math.abs(cur.gamma - ref.gamma);
        tiltDiff = Math.max(db, dg);
      }
      const angleScore = (tiltDiff == null) ? null : (1 - clamp01(tiltDiff / 18));
      const GLARE_MAX = 0.10;
      const glareScore = 1 - clamp01((cur.overPct ?? 0) / GLARE_MAX);
      const stateFrom = (s) => (s > 0.90 ? "g-good" : (s > 0.78 ? "g-mid" : "g-bad"));
      setGaugeState(gGlareGauge, gGlareCircle, glareScore, stateFrom(glareScore));
      if (angleScore == null) {
        gAngleGauge.classList.remove("g-good","g-mid","g-bad");
        gAngleGauge.classList.add("g-na");
        gAngleCircle.style.setProperty("--p", 0);
      } else {
        setGaugeState(gAngleGauge, gAngleCircle, angleScore, stateFrom(angleScore));
      }
    }

    // --- COLOR LOCKS ---
    async function lockRef() {
      const btn = document.getElementById("btn-lock-ref");
      if (btn.disabled) return;
      btn.disabled = true;
      const ghostData = captureGhostImage();
      ghostOverlay.src = ghostData;
      ghostOverlay.classList.add("active");
      const sample = await captureSmartSample();
      btn.disabled = false;
      if (!sample) return;
      savedRefLab = { ...sample.lab };
      updateCard("ref", savedRefLab, sample.rgb);
      document.getElementById("card-ref").classList.add("active-ref");
      const m = readLiveQuality();
      if (m) refMetrics = { ...m };
      flashTarget();
      tryCalculate();
      lucide.createIcons();
    }
    async function lockSam() {
      const btn = document.getElementById("btn-lock-sam");
      if (btn.disabled) return;
      btn.disabled = true;
      const sample = await captureSmartSample();
      btn.disabled = false;
      if (!sample) return;
      savedSamLab = { ...sample.lab };
      updateCard("sam", savedSamLab, sample.rgb);
      document.getElementById("card-sam").classList.add("active-sam");
      flashTarget();
      tryCalculate();
      lucide.createIcons();
    }
    function flashTarget() {
      const tb = document.getElementById("target-box");
      tb.classList.remove("flash"); void tb.offsetWidth; tb.classList.add("flash");
    }
    function updateCard(type, lab, rgb) {
      document.getElementById(`preview-${type}`).style.background = rgb;
      document.getElementById(`${type}-l`).innerText = lab.L;
      document.getElementById(`${type}-a`).innerText = lab.a;
      document.getElementById(`${type}-b`).innerText = lab.b;
      const lVal = Math.max(0, Math.min(100, parseFloat(lab.L)));
      const marker = document.getElementById(`marker-${type}`);
      marker.classList.add("visible");
      marker.style.bottom = lVal + "%";
    }
    function resetAll() {
      savedRefLab = null; savedSamLab = null;
      refMetrics = null; liveMetrics = null;
      toggleCameraLock(false);
      ["ref", "sam"].forEach((type) => {
        document.getElementById(`card-${type}`).classList.remove("active-ref", "active-sam");
        document.getElementById(`preview-${type}`).style.background = "#334155";
        document.getElementById(`${type}-l`).innerText = "-";
        document.getElementById(`${type}-a`).innerText = "-";
        document.getElementById(`${type}-b`).innerText = "-";
        document.getElementById(`marker-${type}`).classList.remove("visible");
      });
      ghostOverlay.classList.remove("active");
      setTimeout(() => { ghostOverlay.src = ""; }, 300);
      document.getElementById("delta-val").innerText = "--";
      document.getElementById("result-dashboard").className = "result-dashboard";
      document.getElementById("delta-msg").innerText = "READY";
      document.getElementById("advice-content").innerHTML = "";
      document.getElementById("advice-placeholder").style.display = "flex";
      showGuidance(false);
      lucide.createIcons();
    }

    // --- TORCH ---
    async function setTorch(on) {
      if (!videoTrack || !torchSupported || !videoTrack.applyConstraints) return false;
      try { await videoTrack.applyConstraints({ advanced: [{ torch: !!on }] }); return true; } catch (e) { return false; }
    }
    function updateTorchUI() {
      const btn = document.getElementById("btn-torch");
      if (!btn) return;
      if (isTorchOn) {
        btn.innerHTML = '<i data-lucide="flashlight-off" style="width:18px;"></i>';
        btn.style.borderColor = "rgba(255,255,255,0.35)";
      } else {
        btn.innerHTML = '<i data-lucide="flashlight" style="width:18px;"></i>';
        btn.style.borderColor = "rgba(255,255,255,0.12)";
      }
      lucide.createIcons();
    }
    async function toggleTorchHold() {
      if (isTorchBusy) return;
      isTorchBusy = true;
      const next = !isTorchOn;
      try {
        if (torchSupported && videoTrack?.applyConstraints) {
          const ok = await setTorch(next);
          if (!ok && next) {
            document.body.classList.add("screen-lamp");
            isTorchOn = true;
            updateTorchUI();
            return;
          }
          isTorchOn = next;
          if (!isTorchOn) document.body.classList.remove("screen-lamp");
          updateTorchUI();
          return;
        }
        isTorchOn = next;
        document.body.classList.toggle("screen-lamp", isTorchOn);
        updateTorchUI();
      } finally { isTorchBusy = false; }
    }

    // --- CALC ---
    function tryCalculate() {
      if (savedRefLab && savedSamLab) {
        let samForCalc = { ...savedSamLab };
        let refL = parseFloat(savedRefLab.L);
        let samL = parseFloat(savedSamLab.L);
        let diffL = samL - refL;
        const TEXTURE_MODE = true;
        if (TEXTURE_MODE) {
          if (diffL < 0) {
            const DAMPEN_FACTOR = 0.3;
            samForCalc.L = (refL + (diffL * DAMPEN_FACTOR)).toFixed(1);
          }
        }
        let dE = 0;
        if (deltaMode === "2000") dE = calculateDeltaE2000(savedRefLab, samForCalc);
        else if (deltaMode === "94") dE = calculateDeltaE94(savedRefLab, samForCalc);
        else dE = calculateDeltaE76(savedRefLab, samForCalc);
        const dash = document.getElementById("result-dashboard");
        document.getElementById("delta-val").innerText = dE.toFixed(2);
        dash.classList.remove("status-match", "status-close", "status-diff");
        if (dE <= 1.0) { dash.classList.add("status-match"); document.getElementById("delta-msg").innerText = "EXACT"; }
        else if (dE <= 2.5) { dash.classList.add("status-close"); document.getElementById("delta-msg").innerText = "CLOSE"; }
        else { dash.classList.add("status-diff"); document.getElementById("delta-msg").innerText = "DIFF"; }
        generateAdvice(savedRefLab, samForCalc);
      }
    }
    function generateAdvice(ref, curr) {
      const dL = parseFloat(ref.L) - parseFloat(curr.L);
      const da = parseFloat(ref.a) - parseFloat(curr.a);
      const db = parseFloat(ref.b) - parseFloat(curr.b);
      const th = 1.0;
      const container = document.getElementById("advice-content");
      const placeholder = document.getElementById("advice-placeholder");
      container.innerHTML = "";
      let actions = [];
      if (dL > th) actions.push({ icon: "sun", text: "Lighten", det: "+White", col: "#fff" });
      else if (dL < -th) actions.push({ icon: "moon", text: "Darken", det: "+Black", col: "#94a3b8" });
      if (da > th) actions.push({ icon: "droplet", text: "Add Red", det: "+Red", col: "#f87171" });
      else if (da < -th) actions.push({ icon: "droplet", text: "Add Green", det: "+Grn", col: "#4ade80" });
      if (db > th) actions.push({ icon: "droplet", text: "Add Yellow", det: "+Yel", col: "#facc15" });
      else if (db < -th) actions.push({ icon: "droplet", text: "Add Blue", det: "+Blu", col: "#60a5fa" });
      if (actions.length === 0) actions.push({ icon: "check-circle", text: "Perfect", det: "Good Match", col: "#10b981" });
      placeholder.style.display = "none";
      actions.forEach((a) => {
        const div = document.createElement("div");
        div.className = "advice-item";
        div.innerHTML = `<div class="adv-icon-row" style="color:${a.col}"><i data-lucide="${a.icon}" width="14"></i> ${a.text}</div><div class="adv-detail">${a.det}</div>`;
        container.appendChild(div);
      });
      lucide.createIcons();
    }
    function drawABGraph() {
      const w = plotCanvas.width, h = plotCanvas.height;
      const cx = w / 2, cy = h / 2;
      if (bgImageData) plotCtx.putImageData(bgImageData, 0, 0); else plotCtx.clearRect(0, 0, w, h);
      if (savedRefLab) drawDot(savedRefLab, "#000", "#3b82f6");
      if (savedSamLab) drawDot(savedSamLab, "#000", "#ffffff");
      if (savedRefLab && savedSamLab) {
        const rx = cx + parseFloat(savedRefLab.a), ry = cy - parseFloat(savedRefLab.b);
        const sx = cx + parseFloat(savedSamLab.a), sy = cy - parseFloat(savedSamLab.b);
        plotCtx.beginPath(); plotCtx.strokeStyle = "rgba(0,0,0,0.5)"; plotCtx.lineWidth = 1; plotCtx.setLineDash([2, 2]);
        plotCtx.moveTo(rx, ry); plotCtx.lineTo(sx, sy); plotCtx.stroke(); plotCtx.setLineDash([]);
      }
    }
    function drawDot(lab, stroke, fill) {
      const cx = plotCanvas.width/2, cy = plotCanvas.height/2;
      const x = cx + parseFloat(lab.a), y = cy - parseFloat(lab.b);
      plotCtx.beginPath(); plotCtx.fillStyle = fill; plotCtx.arc(x, y, 6, 0, Math.PI * 2); plotCtx.fill();
      plotCtx.lineWidth = 2; plotCtx.strokeStyle = stroke; plotCtx.stroke();
    }
    function changeMode(m) { deltaMode = m; document.getElementById("algo-lbl").innerText = m; tryCalculate(); }
    function renderColorMap() {
      const w = plotCanvas.width, h = plotCanvas.height;
      const cx = w / 2, cy = h / 2;
      const imgData = plotCtx.createImageData(w, h);
      const d = imgData.data;
      const maxDist = Math.min(w, h) / 2;
      for (let y = 0; y < h; y += 2) {
        for (let x = 0; x < w; x += 2) {
          const dx = x - cx, dy = y - cy;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const normDist = Math.min(1, dist / maxDist);
          const angleRad = Math.atan2(-dy, dx);
          let angleDeg = angleRad * (180 / Math.PI); if (angleDeg < 0) angleDeg += 360;
          const rgb = hslToRgb(angleDeg, normDist * 100, 100 - normDist * 55);
          const idx = (y * w + x) * 4;
          const setPx = (i) => { d[i]=rgb.r; d[i+1]=rgb.g; d[i+2]=rgb.b; d[i+3]=255; };
          if(idx<d.length) setPx(idx);
          if(((y+1)*w+(x+1))*4 < d.length) setPx(((y+1)*w+(x+1))*4);
        }
      }
      for (let x=0; x<w; x++) { const idx=(Math.floor(cy)*w+x)*4; d[idx]=255; d[idx+1]=255; d[idx+2]=255; d[idx+3]=40; }
      for (let y=0; y<h; y++) { const idx=(y*w+Math.floor(cx))*4; d[idx]=255; d[idx+1]=255; d[idx+2]=255; d[idx+3]=40; }
      bgImageData = imgData;
    }
    function hslToRgb(h, s, l) {
      s/=100; l/=100;
      const k = (n) => (n + h/30)%12;
      const a = s * Math.min(l, 1-l);
      const f = (n) => l - a * Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n), 1)));
      return { r:Math.round(255*f(0)), g:Math.round(255*f(8)), b:Math.round(255*f(4)) };
    }
    function rgbToLab(r, g, b) {
      let R=r/255, G=g/255, B=b/255;
      R=(R>0.04045)?Math.pow((R+0.055)/1.055,2.4):R/12.92;
      G=(G>0.04045)?Math.pow((G+0.055)/1.055,2.4):G/12.92;
      B=(B>0.04045)?Math.pow((B+0.055)/1.055,2.4):B/12.92;
      let X=(R*0.4124+G*0.3576+B*0.1805)*100, Y=(R*0.2126+G*0.7152+B*0.0722)*100, Z=(R*0.0193+G*0.1192+B*0.9505)*100;
      X/=95.047; Y/=100.000; Z/=108.883;
      X=(X>0.008856)?Math.pow(X,1/3):(7.787*X)+16/116;
      Y=(Y>0.008856)?Math.pow(Y,1/3):(7.787*Y)+16/116;
      Z=(Z>0.008856)?Math.pow(Z,1/3):(7.787*Z)+16/116;
      return { L:((116*Y)-16).toFixed(1), a:(500*(X-Y)).toFixed(1), b:(200*(Y-Z)).toFixed(1) };
    }
    function calculateDeltaE76(l1,l2){ return Math.sqrt(Math.pow(l2.L-l1.L,2)+Math.pow(l2.a-l1.a,2)+Math.pow(l2.b-l1.b,2)); }
    function calculateDeltaE94(l1,l2){
      const L1=parseFloat(l1.L), a1=parseFloat(l1.a), b1=parseFloat(l1.b);
      const L2=parseFloat(l2.L), a2=parseFloat(l2.a), b2=parseFloat(l2.b);
      const C1=Math.sqrt(a1**2+b1**2), C2=Math.sqrt(a2**2+b2**2);
      const dL=L1-L2, dC=C1-C2, da=a1-a2, db=b1-b2;
      const dH=Math.sqrt(Math.max(0, da**2+db**2-dC**2));
      const SC=1+0.045*C1, SH=1+0.015*C1;
      return Math.sqrt(dL**2+(dC/SC)**2+(dH/SH)**2);
    }
    function calculateDeltaE2000(l1,l2){
      const L1=parseFloat(l1.L),a1=parseFloat(l1.a),b1=parseFloat(l1.b);
      const L2=parseFloat(l2.L),a2=parseFloat(l2.a),b2=parseFloat(l2.b);
      const deg2rad=d=>d*Math.PI/180, rad2deg=r=>r*180/Math.PI;
      const C1=Math.sqrt(a1**2+b1**2), C2=Math.sqrt(a2**2+b2**2), avgC=(C1+C2)/2;
      const G=0.5*(1-Math.sqrt(avgC**7/(avgC**7+25**7)));
      const a1p=(1+G)*a1, a2p=(1+G)*a2;
      const C1p=Math.sqrt(a1p**2+b1**2), C2p=Math.sqrt(a2p**2+b2**2);
      const h1p=(a1p===0&&b1===0)?0:rad2deg(Math.atan2(b1,a1p))+(rad2deg(Math.atan2(b1,a1p))<0?360:0);
      const h2p=(a2p===0&&b2===0)?0:rad2deg(Math.atan2(b2,a2p))+(rad2deg(Math.atan2(b2,a2p))<0?360:0);
      const dLp=L2-L1, dCp=C2p-C1p;
      let dhp=0; if(C1p*C2p!==0) dhp=(Math.abs(h2p-h1p)<=180)?h2p-h1p:(h2p-h1p>180?h2p-h1p-360:h2p-h1p+360);
      const dHp=2*Math.sqrt(C1p*C2p)*Math.sin(deg2rad(dhp/2));
      const avgLp=(L1+L2)/2, avgCp=(C1p+C2p)/2;
      let avghp=0; if(C1p*C2p!==0) avghp=(Math.abs(h1p-h2p)<=180)?(h1p+h2p)/2:((h1p+h2p<360)?(h1p+h2p+360)/2:(h1p+h2p-360)/2);
      const T=1-0.17*Math.cos(deg2rad(avghp-30))+0.24*Math.cos(deg2rad(2*avghp))+0.32*Math.cos(deg2rad(3*avghp+6))-0.20*Math.cos(deg2rad(4*avghp-63));
      const SL=1+((0.015*(avgLp-50)**2)/Math.sqrt(20+(avgLp-50)**2)), SC=1+0.045*avgCp, SH=1+0.015*avgCp*T;
      const dTheta = 30 * Math.exp( -Math.pow((avghp-275)/25, 2) );
      const RC=2*Math.sqrt(avgCp**7/(avgCp**7+25**7)), RT=-Math.sin(deg2rad(2*dTheta))*RC;
      return Math.sqrt((dLp/SL)**2+(dCp/SC)**2+(dHp/SH)**2+RT*(dCp/SC)*(dHp/SH));
    }

    function applyAutoFitLayout() {
      const frame=document.querySelector(".app-frame"), header=document.querySelector("header");
      if(!frame||!header)return;
      const H=frame.getBoundingClientRect().height, headerH=header.offsetHeight;
      const tabH = 60;
      const remain=Math.max(0, H-headerH-tabH);
      const viewportH=Math.max(120,Math.min(270,Math.round(remain*0.34)));
      const panelRemain=Math.max(0, remain-viewportH);
      const vizH=Math.max(76,Math.min(175,Math.round(panelRemain*0.24)));
      const gap=Math.max(10,Math.min(18,Math.round(panelRemain*0.06)));
      document.documentElement.style.setProperty("--viewport-h",viewportH+"px");
      document.documentElement.style.setProperty("--viz-h",vizH+"px");
      document.documentElement.style.setProperty("--gap-layout",gap+"px");
      requestAnimationFrame(resizeGraph);
    }

    applyAutoFitLayout();
    setCompactMode();

    const frameEl=document.querySelector(".app-frame");
    if(frameEl && "ResizeObserver" in window) new ResizeObserver(()=>{ applyAutoFitLayout(); setCompactMode(); }).observe(frameEl);

    document.addEventListener("visibilitychange", async()=>{
      if(document.hidden && isTorchOn){
        if(torchSupported) await setTorch(false);
        document.body.classList.remove("screen-lamp");
        isTorchOn=false;
        updateTorchUI();
      }
    });
    window.addEventListener("beforeunload", async()=>{ if(torchSupported) await setTorch(false); });

    initCamera();
  </script>
</body>
</html>