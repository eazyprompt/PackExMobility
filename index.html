<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
  />
  <title>PackEx: Smart Corrugated + Glue Gap</title>

  <link rel="icon" type="image/png" href="./logo.png" />
  <link rel="apple-touch-icon" href="./logo.png" />
  <meta name="theme-color" content="#020617" />

  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;800&family=JetBrains+Mono:wght@500;700;800&display=swap"
    rel="stylesheet"
  />
  <script src="https://cdn.jsdelivr.net/npm/lucide@0.321.0/dist/umd/lucide.min.js"></script>

  <style>
    :root {
      --bg-body: #0f172a;
      --bg-card: #1e293b;
      --bg-sidebar: #172554;
      --border-subtle: rgba(255, 255, 255, 0.12);
      --text-main: #ffffff;
      --text-muted: #94a3b8;
      --primary: #3b82f6;
      --primary-glow: rgba(59, 130, 246, 0.5);
      --sample: #ffffff;
      --success: #34d399;
      --warn: #fbbf24;
      --danger: #f87171;
      --neon-green: #00ff41;
      --radius-lg: 18px;
      --font-ui: "Inter", sans-serif;
      --font-num: "JetBrains Mono", monospace;

      --frame-gap: clamp(18px, 6.5vw, 72px);
      --gap-layout: 16px;
      --viewport-h: 220px;
      --viz-h: 150px;
      --app-h: 100dvh;
      --tab-h: 60px;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }

    body {
      background: #020617;
      color: var(--text-main);
      font-family: var(--font-ui);
      margin: 0;
      width: 100vw;
      height: var(--app-h);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    body::after{
      content:""; position: fixed; inset: 0; background: rgba(255,255,255,0.85);
      opacity: 0; pointer-events: none; transition: opacity 120ms ease; z-index: 9999;
    }
    body.screen-flash::after{ opacity: 1; }
    body.screen-lamp::after{ opacity: 1; }

    .app-frame {
      width: calc(100vw - (var(--frame-gap) * 2));
      height: calc(var(--app-h) - (var(--frame-gap) * 2));
      max-width: 500px;
      max-height: calc(var(--app-h) - (var(--frame-gap) * 2));
      background: var(--bg-body);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
      border-radius: 24px;
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.6), 0 0 0 1px var(--border-subtle);
      padding-top: env(safe-area-inset-top);
      padding-bottom: 0;
    }

    header {
      min-height: 64px;
      padding: 0 20px;
      padding-top: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--bg-body);
      border-bottom: 1px solid var(--border-subtle);
      flex-shrink: 0;
      z-index: 50;
      gap: 10px;
      min-width: 0;
    }

    .brand {
      font-weight: 800; font-size: 1.25rem; display: flex; align-items: center; gap: 10px; color: #fff;
      min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .brand i { color: var(--primary); }
    .brand span { color: var(--primary); font-weight: 400; opacity: 0.9; font-size: 0.8em; }

    .header-controls { display: flex; align-items: center; gap: 10px; min-width: 0; }

    .algo-selector {
      appearance: none; background: #334155; color: #fff; border: 1px solid var(--border-subtle);
      padding: 8px 14px; border-radius: 100px; font-size: 0.75rem; font-weight: 600;
      font-family: var(--font-num); transition: 0.2s; min-width: 0; max-width: 160px;
    }

    .btn-icon-header {
      background: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-subtle); color: #fff;
      width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
      cursor: pointer; transition: 0.2s; flex-shrink: 0;
    }

    .dash-right { display:flex; align-items:center; gap:10px; flex-shrink: 0; min-width: 0; }
    .btn-icon-dash { width: 38px; height: 38px; }

    .viewport {
      height: var(--viewport-h);
      min-height: 0;
      display: flex;
      background: #020617;
      border-bottom: 1px solid var(--border-subtle);
      flex-shrink: 0;
      position: relative;
    }

    .vp-camera {
      flex: 1; position: relative; overflow: hidden; display: flex;
      align-items: center; justify-content: center; border-right: 1px solid var(--border-subtle);
      background: #020617; min-width: 0;
      transition: flex 0.3s ease;
    }

    .vp-camera.full-width { border-right: none; }

    video { width: 100%; height: 100%; object-fit: cover; opacity: 1.0; position: relative; z-index: 1; }

    .ghost-overlay {
      position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover;
      opacity: 0; pointer-events: none; z-index: 5; transition: opacity 0.3s ease; filter: grayscale(0.2);
    }
    .ghost-overlay.active { opacity: 0.35; }

    #sheet-canvas {
        position: absolute; inset:0; width:100%; height:100%;
        pointer-events:none; z-index: 20;
    }

    .vp-side-panel {
      flex: 1; background: var(--bg-sidebar); display: flex; flex-direction: column;
      padding: 16px; overflow-y: auto; flex-shrink: 0;
      box-shadow: inset 5px 0 15px rgba(0, 0, 0, 0.2); min-width: 0;
      transition: width 0.3s ease, flex 0.3s ease;
    }

    .vp-side-panel.hidden { display: none; }

    .hud-overlay {
      position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
      pointer-events: none; z-index: 10;
    }

    .target-box {
      width: 42px; height: 42px; position: relative;
      box-shadow: 0 0 0 100vmax rgba(2, 6, 23, 0.6);
      border-radius: 12px; transition: transform 0.1s;
    }
    .target-box::before {
      content: ""; position: absolute; inset: -1px;
      border: 2px solid rgba(255, 255, 255, 0.9); border-radius: 12px;
    }
    .target-box.flash { transform: scale(0.95); }
    .target-box.flash::before { border-color: var(--primary); box-shadow: 0 0 25px var(--primary); }

    .roi-box {
      width: 60px;
      height: 80%;
      position: relative;
      border: 2px dashed rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      display: flex; justify-content: center;
      box-shadow: 0 0 0 100vmax rgba(0,0,0,0.4);
    }
    .roi-label {
        background: rgba(0,0,0,0.6); color: #fff; font-size: 0.6rem; padding: 2px 6px;
        border-radius: 4px; position: absolute; top: -22px; font-weight: 700;
        white-space: nowrap;
    }

    .crosshair { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; opacity: 0.8; }
    .ch-c { width: 4px; height: 4px; background: #fff; border-radius: 50%; box-shadow: 0 0 2px #000; }

    .vp-header {
      font-size: 0.7rem; font-weight: 800; color: #60a5fa;
      text-transform: uppercase; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;
    }

    .advice-item {
      background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px; padding: 12px; margin-bottom: 10px; animation: slideIn 0.3s ease;
    }
    .adv-icon-row { display: flex; align-items: center; gap: 8px; font-size: 0.8rem; font-weight: 700; color: #fff; margin-bottom: 4px; }
    .adv-detail { font-size: 0.7rem; color: var(--text-muted); margin-left: 2px; }

    .placeholder-state {
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      height: 100%; opacity: 0.35; text-align: center; gap: 10px; color: #94a3b8;
    }

    @keyframes slideIn { from { opacity: 0; transform: translateX(10px); } to { opacity: 1; transform: translateX(0); } }

    .panel {
      flex: 1; background: var(--bg-body); display: flex; flex-direction: column;
      overflow: hidden; padding-top: var(--gap-layout); padding-bottom: 0;
      min-height: 0;
    }

    .panel-content {
      padding: 0 20px; display: flex; flex-direction: column; gap: var(--gap-layout);
      margin: 0 auto; width: 100%; height: 100%; min-height: 0;
      overflow-x: hidden; overflow-y: auto; -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain; padding-bottom: 70px;
    }
    .panel-content::-webkit-scrollbar{ width:0; height:0; }

    .result-dashboard {
      display: flex; gap: 12px; justify-content: space-between; align-items: center;
      background: linear-gradient(145deg, #1e293b 0%, #0f172a 100%);
      border: 1px solid var(--border-subtle); border-radius: var(--radius-lg);
      padding: clamp(12px, 2.2vw, 16px) clamp(14px, 2.5vw, 20px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2); flex-shrink: 0; min-width: 0; flex-wrap: wrap;
    }

    .res-left { display: flex; flex-direction: column; gap: 2px; min-width: 0; }
    .res-label { font-size: 0.65rem; color: var(--text-muted); font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }
    .res-value { font-family: var(--font-num); font-size: clamp(2.0rem, 7vw, 2.5rem); font-weight: 800; color: var(--text-main); line-height: 1; }
    .res-badge {
      padding: 8px 14px; border-radius: 10px; font-size: 0.75rem; font-weight: 800;
      background: #334155; color: #fff; letter-spacing: 0.5px; border: 1px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0; white-space: nowrap;
    }
    .status-match .res-value { color: var(--success); }
    .status-match .res-badge { background: rgba(52, 211, 153, 0.2); color: var(--success); border-color: rgba(52, 211, 153, 0.3); }
    .status-close .res-value { color: var(--warn); }
    .status-close .res-badge { background: rgba(251, 191, 36, 0.2); color: var(--warn); border-color: rgba(251, 191, 36, 0.3); }
    .status-diff .res-value { color: var(--danger); }
    .status-diff .res-badge { background: rgba(248, 113, 113, 0.2); color: var(--danger); border-color: rgba(248, 113, 113, 0.3); }

    .cards-container {
      display: grid; grid-template-columns: 1fr 1fr; gap: clamp(10px, 2.4vw, 16px);
      flex-shrink: 1; min-height: 0;
    }

    .data-card {
      background: var(--bg-card); border: 1px solid var(--border-subtle); border-radius: var(--radius-lg);
      padding: clamp(10px, 2.2vw, 12px); display: flex; flex-direction: column; gap: 10px; transition: 0.3s; min-width: 0;
    }

    .card-top { display: flex; justify-content: space-between; align-items: center; }
    .card-title { font-size: 0.75rem; font-weight: 800; color: var(--text-muted); display: flex; align-items: center; gap: 6px; }
    .color-dot { width: 28px; height: 28px; border-radius: 8px; background: #334155; border: 1px solid rgba(255, 255, 255, 0.15); transition: 0.3s; flex-shrink: 0; }

    .lab-row { display: flex; justify-content: space-between; background: rgba(15, 23, 42, 0.5); border-radius: 8px; padding: 6px; border: 1px solid rgba(255, 255, 255, 0.05); }
    .l-item { flex: 1; text-align: center; border-right: 1px solid rgba(255, 255, 255, 0.1); min-width: 0; }
    .l-item:last-child { border: none; }
    .l-lbl { font-size: 0.55rem; color: #64748b; font-weight: 700; margin-bottom: 2px; }
    .l-val { font-family: var(--font-num); font-size: 0.9rem; font-weight: 700; color: #fff; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    .btn-act {
      width: 100%; padding: 12px; border-radius: 10px; border: none; background: rgba(255, 255, 255, 0.05);
      color: #fff; font-size: 0.75rem; font-weight: 700; cursor: pointer; display: flex; align-items: center; justify-content: center;
      gap: 8px; transition: 0.2s; border: 1px solid transparent; font-size: clamp(0.70rem, 2.8vw, 0.75rem);
      padding: clamp(10px, 3.2vw, 12px);
    }
    .btn-act:active { transform: scale(0.96); }
    .btn-act:disabled { opacity: 0.55; cursor: not-allowed; }

    .data-card.active-ref { border-color: var(--primary); background: linear-gradient(165deg, rgba(59, 130, 246, 0.15), #1e293b 90%); }
    .data-card.active-ref .card-title { color: var(--primary); }
    .data-card.active-ref .btn-act { background: var(--primary); color: #fff; box-shadow: 0 4px 15px var(--primary-glow); }
    .data-card.active-sam { border-color: #fff; background: linear-gradient(165deg, rgba(255, 255, 255, 0.1), #1e293b 90%); }
    .data-card.active-sam .card-title { color: #fff; }
    .data-card.active-sam .btn-act { background: #fff; color: #0f172a; box-shadow: 0 4px 15px rgba(255, 255, 255, 0.2); }

    .viz-section {
      display: flex; gap: 12px; height: var(--viz-h); flex-shrink: 1; min-height: 0;
    }
    .graph-box { flex: 1; background: #020617; border: 1px solid var(--border-subtle); border-radius: var(--radius-lg); position: relative; overflow: hidden; min-width: 0; }

    .plot-legend { position: absolute; top: 10px; left: 10px; z-index: 10; display: flex; gap: 8px; pointer-events: none; }
    .legend-item { font-size: 0.6rem; color: #fff; font-weight: 700; display: flex; align-items: center; gap: 5px; background: rgba(15, 23, 42, 0.7); padding: 3px 8px; border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.1); backdrop-filter: blur(4px); }
    .dot-icon { width: 6px; height: 6px; border-radius: 50%; }
    .di-ref { background: var(--primary); box-shadow: 0 0 5px var(--primary); }
    .di-sam { background: var(--sample); }

    .axis-lbl { position: absolute; font-size: 0.55rem; font-weight: 800; color: rgba(255, 255, 255, 0.6); pointer-events: none; text-shadow: 0 0 4px #000; }
    .ax-t { top: 6px; left: 50%; transform: translateX(-50%); }
    .ax-b { bottom: 6px; left: 50%; transform: translateX(-50%); }
    .ax-l { left: 6px; top: 50%; transform: translateY(-50%) rotate(-90deg); }
    .ax-r { right: 6px; top: 50%; transform: translateY(-50%) rotate(90deg); }

    .l-bar-box { width: 40px; background: var(--bg-card); border: 1px solid var(--border-subtle); border-radius: 50px; display: flex; flex-direction: column; align-items: center; padding: 12px 0; position: relative; flex-shrink: 0; }
    .l-track { width: 6px; flex: 1; background: linear-gradient(to top, #020617, #fff); border-radius: 4px; position: relative; margin: 6px 0; }
    .l-mark { position: absolute; left: 50%; transform: translate(-50%, 50%); width: 14px; height: 14px; border-radius: 50%; border: 3px solid var(--bg-card); opacity: 0; transition: bottom 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
    .l-mark.ref { background: var(--primary); z-index: 1; }
    .l-mark.sam { background: #fff; z-index: 2; width: 12px; height: 12px; border-width: 2px; }
    .l-mark.visible { opacity: 1; }

    canvas { display: block; }
    #proc-canvas { display: none; }

    .guidance-hud{
      position:absolute; left: calc(10px + env(safe-area-inset-left)); bottom: calc(10px + env(safe-area-inset-bottom));
      z-index: 25; pointer-events: none; display:flex; justify-content: flex-start; gap: 8px;
      align-items: center; padding: 6px 8px; border-radius: 14px; background: rgba(2,6,23,.28);
      border: 1px solid rgba(255,255,255,.12); backdrop-filter: blur(8px); box-shadow: 0 10px 30px rgba(0,0,0,.18);
      width: fit-content; max-width: calc(100% - 20px);
    }
    .guidance-hud.hidden{ opacity: 0; transform: translateY(-6px); transition: opacity .18s ease, transform .18s ease; }
    .guidance-hud:not(.hidden){ opacity: 1; transform: translateY(0); transition: opacity .18s ease, transform .18s ease; }
    .gauge{ width: 54px; display:flex; flex-direction: column; align-items:center; gap: 4px; }
    .g-lbl{ font-family: var(--font-num); font-size: .52rem; font-weight: 900; letter-spacing: .08em; color: rgba(255,255,255,.78); text-transform: uppercase; line-height: 1; }
    .g-circle{ --p: 0; --c: rgba(251,191,36,.95); width: 34px; height: 34px; border-radius: 50%; position: relative; background: conic-gradient(var(--c) calc(var(--p) * 1%), rgba(255,255,255,.10) 0); display:flex; align-items:center; justify-content:center; }
    .g-circle::after{ content:""; position:absolute; inset: 3px; border-radius: 50%; background: rgba(2,6,23,.55); border: 1px solid rgba(255,255,255,.10); box-shadow: inset 0 0 0 1px rgba(0,0,0,.25); }
    .g-circle i{ position: relative; z-index: 2; width: 14px !important; height: 14px !important; color: rgba(255,255,255,.92); }
    .g-good .g-circle{ --c: rgba(52,211,153,.95); }
    .g-mid  .g-circle{ --c: rgba(251,191,36,.95); }
    .g-bad  .g-circle{ --c: rgba(248,113,113,.95); }
    .g-na .g-circle{ --p: 0; background: radial-gradient(circle at center, rgba(255,255,255,.10), rgba(255,255,255,.06)); }
    .g-na .g-lbl{ opacity: .55; }

    .app-frame.compact{ --frame-gap: clamp(12px, 4.6vw, 34px); --gap-layout: 12px; --radius-lg: 16px; }
    .app-frame.compact header{ padding-left: 14px; padding-right: 14px; }
    .app-frame.compact .panel-content{ padding-left: 14px; padding-right: 14px; gap: var(--gap-layout); }
    .app-frame.compact .result-dashboard{ padding: 12px 14px; gap: 10px; }
    .app-frame.compact .res-value{ font-size: clamp(1.55rem, 6.2vw, 2.15rem); }
    .app-frame.compact .res-badge{ padding: 7px 12px; font-size: 0.72rem; }
    .app-frame.compact .btn-icon-dash{ width: 36px; height: 36px; }
    .app-frame.compact .data-card{ padding: 10px; border-radius: 16px; }
    .app-frame.compact .card-title{ font-size: 0.72rem; }
    .app-frame.compact .lab-row{ padding: 6px; }
    .app-frame.compact .l-val{ font-size: 0.84rem; }
    .app-frame.compact .btn-act{ padding: 10px; font-size: 0.72rem; }
    .app-frame.compact .viz-section{ height: calc(var(--viz-h) - 14px); }

    @media (max-width: 360px){
      .header-controls{ flex-wrap: wrap; justify-content: flex-end; }
      .algo-selector{ max-width: 128px; padding: 8px 10px; font-size: 0.72rem; }
      .dash-right{ width: 100%; justify-content: space-between; gap: 10px; }
      .btn-icon-dash{ width: 36px; height: 36px; }
    }

    .tab-bar {
        position: absolute; bottom: 0; left: 0; right: 0; height: var(--tab-h);
        background: rgba(15, 23, 42, 0.9); backdrop-filter: blur(10px);
        border-top: 1px solid var(--border-subtle); display: flex;
        justify-content: space-around; align-items: center; z-index: 100;
        padding-bottom: env(safe-area-inset-bottom);
    }
    .tab-item {
        flex: 1; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;
        color: var(--text-muted); gap: 4px; cursor: pointer; transition: 0.2s;
    }
    .tab-item.active { color: var(--primary); }
    .tab-lbl { font-size: 0.65rem; font-weight: 700; }
    .tab-item i { transition: transform 0.2s; }
    .tab-item.active i { transform: translateY(-2px); }

    .display-none { display: none !important; }

    /* Sheet Stats */
    .sheet-stats-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-bottom: 12px;
    }
    .stat-box {
        background: var(--bg-card); border: 1px solid var(--border-subtle); border-radius: var(--radius-lg);
        padding: 12px; display: flex; flex-direction: column; align-items: center; justify-content: center;
        min-height: 72px;
    }
    .stat-lbl { font-size: 0.6rem; color: var(--text-muted); font-weight: 800; margin-bottom: 6px; letter-spacing: .06em; }
    .stat-val { font-family: var(--font-num); font-size: 1.6rem; font-weight: 900; color: #fff; line-height: 1; }
  </style>
</head>

<body>
  <div class="app-frame">
    <header>
      <div class="brand"><i data-lucide="scan-face"></i> PackEx <span>Mobility</span></div>
      <div class="header-controls">
        <div id="ctl-color-algo">
            <select id="algo-select" class="algo-selector" onchange="changeMode(this.value)">
              <option value="2000">DE 2000</option>
              <option value="94">DE 94</option>
              <option value="76">DE 76</option>
            </select>
        </div>
        <button class="btn-icon-header" id="btn-torch" onclick="toggleTorchHold()" title="Torch">
          <i data-lucide="flashlight" style="width: 18px;"></i>
        </button>
      </div>
    </header>

    <div class="viewport">
      <div class="vp-camera" id="vp-camera">
        <video id="webcam" autoplay playsinline muted></video>
        <img id="ghost-overlay" class="ghost-overlay" src="" alt="Ghost Reference" />
        <canvas id="sheet-canvas"></canvas>

        <div id="guidanceHud" class="guidance-hud hidden" aria-label="Capture guidance">
          <div class="gauge" id="gAngleGauge" title="Angle / Tilt">
            <div class="g-circle" id="gAngleCircle"><i data-lucide="rotate-3d"></i></div>
            <div class="g-lbl">ANGLE</div>
          </div>
          <div class="gauge" id="gGlareGauge" title="Glare / Reflection">
            <div class="g-circle" id="gGlareCircle"><i data-lucide="sun"></i></div>
            <div class="g-lbl">GLARE</div>
          </div>
        </div>

        <div class="hud-overlay">
          <div id="target-box" class="target-box">
            <div class="crosshair"><div class="ch-c"></div></div>
          </div>
          <div id="sheet-roi-box" class="roi-box display-none">
             <div class="roi-label">SCAN ZONE</div>
          </div>
        </div>
      </div>

      <div class="vp-side-panel" id="vp-side-panel">
        <div id="side-colex">
          <div class="vp-header"><i data-lucide="bot" style="width: 14px;"></i> AI ASSIST</div>
          <div id="advice-content"></div>
          <div id="advice-placeholder" class="placeholder-state">
            <i data-lucide="scan" style="width: 28px; opacity: 0.55;"></i>
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="panel-content">
        
        <div id="panel-colex" style="display:flex; flex-direction:column; gap:var(--gap-layout);">
          <div id="result-dashboard" class="result-dashboard">
            <div class="res-left">
              <div class="res-label">Delta E <span id="algo-lbl">2000</span></div>
              <div class="res-value" id="delta-val">--</div>
            </div>
            <div class="dash-right">
              <div class="res-badge" id="delta-msg">READY</div>
              <button class="btn-icon-header btn-icon-dash" onclick="resetAll()" title="Reset">
                <i data-lucide="rotate-cw" style="width: 18px;"></i>
              </button>
            </div>
          </div>

          <div class="cards-container">
            <div class="data-card" id="card-ref">
              <div class="card-top">
                <div class="card-title"><i data-lucide="crosshair" style="width: 14px;"></i> REF</div>
                <div class="color-dot" id="preview-ref"></div>
              </div>
              <div class="lab-row">
                <div class="l-item"><div class="l-lbl">L</div><div class="l-val" id="ref-l">-</div></div>
                <div class="l-item"><div class="l-lbl">a</div><div class="l-val" id="ref-a">-</div></div>
                <div class="l-item"><div class="l-lbl">b</div><div class="l-val" id="ref-b">-</div></div>
              </div>
              <button class="btn-act" id="btn-lock-ref" onclick="lockRef()">
                <i data-lucide="fingerprint" style="width: 16px;"></i> CAPTURE
              </button>
            </div>

            <div class="data-card" id="card-sam">
              <div class="card-top">
                <div class="card-title"><i data-lucide="zap" style="width: 14px;"></i> SAMPLE</div>
                <div class="color-dot" id="preview-sam"></div>
              </div>
              <div class="lab-row">
                <div class="l-item"><div class="l-lbl">L</div><div class="l-val" id="sam-l">-</div></div>
                <div class="l-item"><div class="l-lbl">a</div><div class="l-val" id="sam-a">-</div></div>
                <div class="l-item"><div class="l-lbl">b</div><div class="l-val" id="sam-b">-</div></div>
              </div>
              <button class="btn-act" id="btn-lock-sam" onclick="lockSam()">
                <i data-lucide="scan-line" style="width: 16px;"></i> CAPTURE
              </button>
            </div>
          </div>

          <div class="viz-section">
            <div class="graph-box">
              <div class="plot-legend">
                <div class="legend-item"><div class="dot-icon di-ref"></div> REF</div>
                <div class="legend-item"><div class="dot-icon di-sam"></div> SAM</div>
              </div>
              <div class="axis-lbl ax-t">+b Yel</div>
              <div class="axis-lbl ax-b">-b Blu</div>
              <div class="axis-lbl ax-l">-a Grn</div>
              <div class="axis-lbl ax-r">+a Red</div>
              <canvas id="ab-plot"></canvas>
            </div>
            <div class="l-bar-box">
              <div style="font-size: 0.5rem; color: #64748b; font-weight: 700;">L*</div>
              <div class="l-track">
                <div id="marker-ref" class="l-mark ref"></div>
                <div id="marker-sam" class="l-mark sam"></div>
              </div>
            </div>
          </div>
        </div>

        <div id="panel-gluegap" class="display-none" style="display:flex; flex-direction:column; gap:var(--gap-layout);">
          <div class="sheet-stats-container">
            <div class="stat-box">
              <div class="stat-lbl">TOTAL LAYERS</div>
              <div class="stat-val" id="sh-count">0</div>
            </div>
            <div class="stat-box">
              <div class="stat-lbl">GROOVES FOUND</div>
              <div class="stat-val" id="sh-found">0</div>
            </div>
            <div class="stat-box">
              <div class="stat-lbl">MISSING</div>
              <div class="stat-val" id="sh-missing">0</div>
            </div>
            <div class="stat-box">
              <div class="stat-lbl">AVG WIDTH</div>
              <div class="stat-val" id="sh-avg">-</div>
            </div>
          </div>

          <button class="btn-act" id="btn-sheet-cap" onclick="toggleSheetCapture()" style="background:var(--primary); box-shadow:0 4px 15px var(--primary-glow);">
            <i data-lucide="camera" style="width: 16px;"></i> CAPTURE / FREEZE
          </button>
        </div>

      </div>
    </div>

    <div class="tab-bar">
      <div class="tab-item active" id="tab-colex" onclick="switchTab('colex')">
        <i data-lucide="palette"></i>
        <span class="tab-lbl">COLEX</span>
      </div>
      <div class="tab-item" id="tab-gluegap" onclick="switchTab('gluegap')">
        <i data-lucide="layers"></i>
        <span class="tab-lbl">GLUE GAP</span>
      </div>
    </div>

  </div>

  <canvas id="proc-canvas" width="100" height="100"></canvas>

  <script>
    lucide.createIcons();

    // --- GLOBALS ---
    const video = document.getElementById("webcam");
    const procCanvas = document.getElementById("proc-canvas");
    const procCtx = procCanvas.getContext("2d", { willReadFrequently: true });
    const plotCanvas = document.getElementById("ab-plot");
    const plotCtx = plotCanvas.getContext("2d", { willReadFrequently: true });
    const sheetCanvas = document.getElementById("sheet-canvas");
    const sheetCtx = sheetCanvas.getContext("2d");
    const ghostOverlay = document.getElementById("ghost-overlay");
    const guidanceHud = document.getElementById("guidanceHud");
    const gAngleGauge = document.getElementById("gAngleGauge");
    const gGlareGauge = document.getElementById("gGlareGauge");
    const gAngleCircle = document.getElementById("gAngleCircle");
    const gGlareCircle = document.getElementById("gGlareCircle");

    // 7. เปลี่ยน default activeTab เป็น 'colex'
    let activeTab = 'colex';
    let isProcessing = false;
    let liveLab = null;
    let liveRGB = null;
    let savedRefLab = null, savedSamLab = null;
    let bgImageData = null;
    let deltaMode = "2000";
    let videoTrack = null;
    let torchSupported = false;
    let isTorchBusy = false;
    let isTorchOn = false;
    let cameraLocked = false;
    let lastOri = { beta: null, gamma: null, alpha: null };
    let refMetrics = null;
    let liveMetrics = null;

    // Sheet Globals
    let sheetFrozen = false;
    let sheetResults = [];

    const SHEET_ROI_W = 60;
    const EDGE_THRESH = 15;
    const MIN_PEAK_DIST = 8;

    // NEW: Layer sanity thresholds (still count layers even if invalid; width=0)
    const LAYER_MIN_H = 5;
    const LAYER_MAX_H = 120;

    // --- LAYOUT ---
    function setCompactMode() {
      const frame = document.querySelector(".app-frame");
      if (!frame) return;
      const vvH = window.visualViewport ? window.visualViewport.height : window.innerHeight;
      const vvW = window.visualViewport ? window.visualViewport.width : window.innerWidth;
      const compact = (vvW <= 390) || (vvH <= 740);
      frame.classList.toggle("compact", compact);
    }
    function setRealAppHeight() {
      const h = window.visualViewport ? window.visualViewport.height : window.innerHeight;
      document.documentElement.style.setProperty("--app-h", `${Math.round(h)}px`);
      setCompactMode();
      if (typeof applyAutoFitLayout === "function") requestAnimationFrame(applyAutoFitLayout);
    }
    setRealAppHeight();
    window.addEventListener("resize", setRealAppHeight);
    window.addEventListener("orientationchange", setRealAppHeight);
    if (window.visualViewport) {
      window.visualViewport.addEventListener("resize", setRealAppHeight);
      window.visualViewport.addEventListener("scroll", setRealAppHeight);
    }

    // --- TABS (Updated for ColEx / Glue Gap) ---
    function switchTab(mode) {
      activeTab = mode;
      document.querySelectorAll('.tab-item').forEach(el => el.classList.remove('active'));
      document.getElementById(`tab-${mode}`).classList.add('active');

      // 8. อัปเดต Logic การสลับแท็บให้รองรับชื่อ colex และ gluegap
      if (mode === 'colex') {
        document.getElementById('ctl-color-algo').classList.remove('display-none');

        const sidePanel = document.getElementById('vp-side-panel');
        sidePanel.classList.remove('hidden');
        document.getElementById('side-colex').classList.remove('display-none'); // was side-color

        document.getElementById('vp-camera').classList.remove('full-width');

        document.getElementById('panel-colex').style.display = 'flex'; // was panel-color
        document.getElementById('target-box').classList.remove('display-none');

        document.getElementById('panel-gluegap').classList.add('display-none'); // was panel-sheet
        document.getElementById('sheet-roi-box').classList.add('display-none');

        sheetFrozen = false;
        sheetCtx.clearRect(0,0,sheetCanvas.width, sheetCanvas.height);

      } else {
        // Mode: gluegap
        document.getElementById('ctl-color-algo').classList.add('display-none');

        const sidePanel = document.getElementById('vp-side-panel');
        sidePanel.classList.add('hidden');

        document.getElementById('vp-camera').classList.add('full-width');

        document.getElementById('panel-colex').style.display = 'none'; // was panel-color
        document.getElementById('target-box').classList.add('display-none');

        document.getElementById('panel-gluegap').classList.remove('display-none'); // was panel-sheet
        document.getElementById('panel-gluegap').style.display = 'flex';

        document.getElementById('sheet-roi-box').classList.remove('display-none');

        resetSheetUI();
      }
      lucide.createIcons();
    }

    // --- CAMERA ---
    async function initCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } },
        });
        video.srcObject = stream;
        videoTrack = stream.getVideoTracks?.()[0] || null;
        try {
          const caps = videoTrack?.getCapabilities?.();
          torchSupported = !!caps?.torch;
        } catch (e) { torchSupported = false; }
        updateTorchUI();
        video.onloadedmetadata = () => {
          resizeGraph();
          sheetCanvas.width = video.videoWidth;
          sheetCanvas.height = video.videoHeight;
          window.addEventListener("resize", resizeGraph);
          isProcessing = true;
          requestAnimationFrame(loop);
        };
      } catch (err) { alert("Camera Error: " + err); }
    }

    function resizeGraph() {
      const container = document.querySelector(".graph-box");
      if (container) {
        plotCanvas.width = container.offsetWidth;
        plotCanvas.height = container.offsetHeight;
        renderColorMap();
        drawABGraph();
      }
    }

    // --- LOOP ---
    function loop() {
      if (!isProcessing) return;

      // 9. ตรวจสอบ loop ตามชื่อ activeTab ใหม่
      if (activeTab === 'colex') {
        readOneSample();
        drawABGraph();
        liveMetrics = readLiveQuality();
        if (refMetrics && liveMetrics) updateGuidanceHud(refMetrics, liveMetrics);
        else showGuidance(false);
      } else {
        // Glue Gap mode
        processSheetFrame();
        showGuidance(false);
      }
      requestAnimationFrame(loop);
    }

    // --- SHEET AR LOGIC (UPDATED: always output per-layer width; missing => 0) ---
    function processSheetFrame() {
      if (sheetFrozen) return;
      if (video.readyState !== video.HAVE_ENOUGH_DATA) return;

      const w = video.videoWidth;
      const h = video.videoHeight;

      if(sheetCanvas.width !== w || sheetCanvas.height !== h) {
        sheetCanvas.width = w; sheetCanvas.height = h;
      }

      const roiX = (w - SHEET_ROI_W) / 2;

      if(procCanvas.width !== SHEET_ROI_W || procCanvas.height !== h) {
        procCanvas.width = SHEET_ROI_W; procCanvas.height = h;
      }

      procCtx.drawImage(video, roiX, 0, SHEET_ROI_W, h, 0, 0, SHEET_ROI_W, h);
      const data = procCtx.getImageData(0, 0, SHEET_ROI_W, h).data;

      // 1) Boundary Detection (edge signal along Y)
      const edgeSignal = new Float32Array(h);
      for(let y = 1; y < h - 1; y++) {
        let rowSum = 0;
        for(let x = 0; x < SHEET_ROI_W; x++) {
          const idx = (y * SHEET_ROI_W + x) * 4;
          const idxUp = ((y - 1) * SHEET_ROI_W + x) * 4;
          const idxDn = ((y + 1) * SHEET_ROI_W + x) * 4;
          const g = (data[idx]*0.299 + data[idx+1]*0.587 + data[idx+2]*0.114);
          const gUp = (data[idxUp]*0.299 + data[idxUp+1]*0.587 + data[idxUp+2]*0.114);
          const gDn = (data[idxDn]*0.299 + data[idxDn+1]*0.587 + data[idxDn+2]*0.114);
          rowSum += Math.abs(gDn - gUp);
        }
        edgeSignal[y] = rowSum / SHEET_ROI_W;
      }

      // 2) Peak picking (boundaries)
      const boundaries = [];
      for(let y = 5; y < h - 5; y++) {
        if(edgeSignal[y] > EDGE_THRESH) {
          let isMax = true;
          for(let k = -MIN_PEAK_DIST/2; k <= MIN_PEAK_DIST/2; k++) {
            if(edgeSignal[y] < edgeSignal[y+k]) { isMax = false; break; }
          }
          if(isMax) {
            if(boundaries.length === 0 || (y - boundaries[boundaries.length-1] > MIN_PEAK_DIST)) {
              boundaries.push(y);
            }
          }
        }
      }

      // If we can't form layers, clear UI
      const totalLayers = Math.max(0, boundaries.length - 1);

      sheetCtx.clearRect(0,0,w,h);

      const results = [];
      let totalW = 0;
      let foundCount = 0;

      // AR text styling
      sheetCtx.font = "bold 42px 'JetBrains Mono', monospace";
      sheetCtx.textBaseline = "middle";
      sheetCtx.shadowColor = "black";
      sheetCtx.shadowBlur = 4;
      sheetCtx.lineWidth = 4;

      // 3) Per-layer measurement (ALWAYS one result per layer)
      for(let i = 0; i < totalLayers; i++) {
        const y1 = boundaries[i];
        const y2 = boundaries[i+1];
        const hSheet = y2 - y1;
        const yMid = y1 + hSheet/2;

        let widthVal = 0;
        let status = "NO_GROOVE"; // default = missing/unreadable

        if (hSheet >= LAYER_MIN_H && hSheet <= LAYER_MAX_H) {
          const groove = measureGrooveWidth(data, SHEET_ROI_W, y1, y2);
          if (groove.status === 'OK' && groove.width > 0) {
            widthVal = groove.width;
            status = "OK";
            totalW += widthVal;
            foundCount++;
          } else {
            widthVal = 0;
            status = "NO_GROOVE"; // could be truly missing OR unreadable
          }
        } else {
          widthVal = 0;
          status = "INVALID_LAYER"; // still show Width:0 (keeps indexing stable)
        }

        results.push({ layer: i+1, y: yMid, w: widthVal, status });

        // --- DRAWING (ALWAYS show Width, missing => 0) ---
        const boxH = Math.max(14, Math.min(hSheet - 2, 30));
        const boxW = 80;
        const boxX = (w/2) - boxW - 20;
        const boxY = yMid - (boxH/2);

        const isOk = (status === "OK");
        const stroke = isOk ? "#00ff41" : "#f87171";
        const fill = stroke;

        sheetCtx.strokeStyle = stroke;
        sheetCtx.strokeRect(boxX, boxY, boxW, boxH);

        sheetCtx.fillStyle = fill;
        const textX = boxX + boxW + 20;
        // Display integer width (0 included)
        sheetCtx.fillText(`Width:${Math.round(widthVal)}`, textX, yMid);
      }

      // 4) Update Stats Panel
      const missing = Math.max(0, totalLayers - foundCount);
      const avg = foundCount > 0 ? (totalW / foundCount) : 0;

      document.getElementById('sh-count').innerText = String(totalLayers);
      document.getElementById('sh-found').innerText = String(foundCount);
      document.getElementById('sh-missing').innerText = String(missing);
      document.getElementById('sh-avg').innerText = (foundCount > 0 ? avg.toFixed(1) : "-");

      sheetResults = results;
    }

    function measureGrooveWidth(data, w, yStart, yEnd) {
      const profile = new Float32Array(w);
      let minVal = 255, maxVal = 0;
      let minX = 0;

      for(let x = 0; x < w; x++) {
        let colSum = 0, count = 0;
        for(let y = yStart + 2; y < yEnd - 2; y++) {
          const idx = (y * w + x) * 4;
          colSum += (data[idx]*0.299 + data[idx+1]*0.587 + data[idx+2]*0.114);
          count++;
        }
        const val = count ? colSum/count : 0;
        profile[x] = val;
        if(val < minVal) { minVal = val; minX = x; }
        if(val > maxVal) { maxVal = val; }
      }

      // Not enough contrast -> treat as missing/unreadable
      if(maxVal - minVal < 10) return { width: 0, status: 'FAIL' };

      const threshold = minVal + (maxVal - minVal) * 0.4;
      let xL = minX, xR = minX;
      while(xL > 0 && profile[xL] < threshold) xL--;
      while(xR < w - 1 && profile[xR] < threshold) xR++;

      const width = Math.max(0, xR - xL);
      if (width <= 0) return { width: 0, status: 'FAIL' };

      return { width, status: 'OK' };
    }

    function toggleSheetCapture() {
      const btn = document.getElementById('btn-sheet-cap');
      if(sheetFrozen) {
        sheetFrozen = false;
        btn.innerHTML = '<i data-lucide="camera" style="width:16px;"></i> CAPTURE / FREEZE';
        btn.style.background = 'var(--primary)';
      } else {
        sheetFrozen = true;
        btn.innerHTML = '<i data-lucide="rotate-ccw" style="width:16px;"></i> RESUME';
        btn.style.background = '#334155';
      }
      lucide.createIcons();
    }

    function resetSheetUI() {
      document.getElementById('sh-count').innerText = "0";
      document.getElementById('sh-found').innerText = "0";
      document.getElementById('sh-missing').innerText = "0";
      document.getElementById('sh-avg').innerText = "-";
      sheetCtx.clearRect(0,0,sheetCanvas.width, sheetCanvas.height);
      sheetResults = [];
    }

    // --- COLOR HELPERS (Original) ---
    function getSmartAverage(arr) {
      if (arr.length === 0) return 0;
      arr.sort((a, b) => a - b);
      const trimAmt = Math.floor(arr.length * 0.25);
      const target = arr.slice(trimAmt, arr.length - trimAmt);
      if (target.length === 0) return arr[Math.floor(arr.length / 2)];
      const sum = target.reduce((a, b) => a + b, 0);
      return Math.round(sum / target.length);
    }
    function readOneSample() {
      if (video.readyState !== video.HAVE_ENOUGH_DATA) return null;
      const W = 100, H = 100;
      if (procCanvas.width !== W) { procCanvas.width=W; procCanvas.height=H; }
      const sx = (video.videoWidth - W) / 2;
      const sy = (video.videoHeight - H) / 2;
      procCtx.drawImage(video, sx, sy, W, H, 0, 0, W, H);
      const frame = procCtx.getImageData(0, 0, W, H);
      const data = frame.data;
      let rList = [], gList = [], bList = [];
      for (let i = 0; i < data.length; i += 20) {
        rList.push(data[i]); gList.push(data[i + 1]); bList.push(data[i + 2]);
      }
      const r = getSmartAverage(rList);
      const g = getSmartAverage(gList);
      const b = getSmartAverage(bList);
      const rgb = `rgb(${r},${g},${b})`;
      const lab = rgbToLab(r, g, b);
      liveRGB = rgb;
      liveLab = lab;
      return { rgb, lab };
    }
    function wait(ms) { return new Promise((r) => setTimeout(r, ms)); }
    async function captureSmartSample() {
      if (isTorchBusy) return null;
      isTorchBusy = true;
      try {
        const frames = 10;
        let sumL = 0, sumA = 0, sumB = 0;
        let lastRGB = "";
        for (let i = 0; i < frames; i++) {
          const sample = readOneSample();
          if (sample) {
            sumL += parseFloat(sample.lab.L);
            sumA += parseFloat(sample.lab.a);
            sumB += parseFloat(sample.lab.b);
            lastRGB = sample.rgb;
          }
          await wait(30);
        }
        return {
          rgb: lastRGB,
          lab: { L: (sumL / frames).toFixed(1), a: (sumA / frames).toFixed(1), b: (sumB / frames).toFixed(1) }
        };
      } finally { isTorchBusy = false; }
    }
    async function toggleCameraLock(lock) {
      if (!videoTrack) return;
      try {
        const capabilities = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
        const constraints = { advanced: [] };
        if (lock) {
          if (capabilities.whiteBalanceMode?.includes('manual')) constraints.advanced.push({ whiteBalanceMode: 'manual' });
          if (capabilities.exposureMode?.includes('manual')) constraints.advanced.push({ exposureMode: 'manual' });
        } else {
          if (capabilities.whiteBalanceMode?.includes('continuous')) constraints.advanced.push({ whiteBalanceMode: 'continuous' });
          if (capabilities.exposureMode?.includes('continuous')) constraints.advanced.push({ exposureMode: 'continuous' });
        }
        if (constraints.advanced.length > 0) {
          await videoTrack.applyConstraints(constraints);
          cameraLocked = lock;
        }
      } catch (e) { console.warn("Camera locking not supported", e); }
    }
    function captureGhostImage() {
      const c = document.createElement("canvas");
      c.width = video.videoWidth; c.height = video.videoHeight;
      c.getContext("2d").drawImage(video, 0, 0);
      return c.toDataURL("image/jpeg", 0.8);
    }

    // --- METRICS ---
    function computeRegionMetrics(imgData, w, h) {
      const d = imgData.data;
      let sumL = 0, over = 0, n = 0, sharp = 0;
      const lumaAt = (i) => (0.2126 * d[i] + 0.7152 * d[i + 1] + 0.0722 * d[i + 2]);
      const lum = new Float32Array(w * h);
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const idx = (y * w + x) * 4;
          const L = lumaAt(idx);
          lum[y * w + x] = L;
          sumL += L; n++;
          if (d[idx] >= 245 && d[idx + 1] >= 245 && d[idx + 2] >= 245) over++;
        }
      }
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const here = lum[y * w + x];
          if (x + 1 < w) sharp += Math.abs(here - lum[y * w + (x + 1)]);
          if (y + 1 < h) sharp += Math.abs(here - lum[(y + 1) * w + x]);
        }
      }
      return { meanLuma: sumL / Math.max(1, n), sharpness: sharp, overPct: over / Math.max(1, n) };
    }
    function readLiveQuality() {
      if (video.readyState !== video.HAVE_ENOUGH_DATA) return null;
      const w = 50, h = 50;
      if(procCanvas.width !== w) { procCanvas.width = w; procCanvas.height = h; }
      const sx = (video.videoWidth - w) / 2;
      const sy = (video.videoHeight - h) / 2;
      procCtx.drawImage(video, sx, sy, w, h, 0, 0, w, h);
      const m = computeRegionMetrics(procCtx.getImageData(0,0,w,h), w, h);
      return { ...m, beta: lastOri?.beta ?? null, gamma: lastOri?.gamma ?? null };
    }
    const clamp01 = (x) => Math.max(0, Math.min(1, x));
    function showGuidance(visible) {
      if (!guidanceHud) return;
      guidanceHud.classList.toggle("hidden", !visible);
    }
    function setGaugeState(gaugeEl, circleEl, score01, stateClass) {
      if (!gaugeEl || !circleEl) return;
      gaugeEl.classList.remove("g-good", "g-mid", "g-bad", "g-na");
      if (stateClass) gaugeEl.classList.add(stateClass);
      const p = Math.round(Math.max(0, Math.min(1, score01)) * 100);
      circleEl.style.setProperty("--p", p);
    }
    function updateGuidanceHud(ref, cur) {
      if (!ref || !cur) { showGuidance(false); return; }
      showGuidance(true);
      let tiltDiff = null;
      if (typeof ref.beta === "number" && typeof ref.gamma === "number" && typeof cur.beta === "number" && typeof cur.gamma === "number") {
        const db = Math.abs(cur.beta - ref.beta);
        const dg = Math.abs(cur.gamma - ref.gamma);
        tiltDiff = Math.max(db, dg);
      }
      const angleScore = (tiltDiff == null) ? null : (1 - clamp01(tiltDiff / 18));
      const GLARE_MAX = 0.10;
      const glareScore = 1 - clamp01((cur.overPct ?? 0) / GLARE_MAX);
      const stateFrom = (s) => (s > 0.90 ? "g-good" : (s > 0.78 ? "g-mid" : "g-bad"));
      setGaugeState(gGlareGauge, gGlareCircle, glareScore, stateFrom(glareScore));
      if (angleScore == null) {
        gAngleGauge.classList.remove("g-good","g-mid","g-bad");
        gAngleGauge.classList.add("g-na");
        gAngleCircle.style.setProperty("--p", 0);
      } else {
        setGaugeState(gAngleGauge, gAngleCircle, angleScore, stateFrom(angleScore));
      }
    }

    // --- COLOR LOCKS ---
    async function lockRef() {
      const btn = document.getElementById("btn-lock-ref");
      if (btn.disabled) return;
      btn.disabled = true;
      const ghostData = captureGhostImage();
      ghostOverlay.src = ghostData;
      ghostOverlay.classList.add("active");
      const sample = await captureSmartSample();
      btn.disabled = false;
      if (!sample) return;
      savedRefLab = { ...sample.lab };
      updateCard("ref", savedRefLab, sample.rgb);
      document.getElementById("card-ref").classList.add("active-ref");
      const m = readLiveQuality();
      if (m) refMetrics = { ...m };
      flashTarget();
      tryCalculate();
      lucide.createIcons();
    }
    async function lockSam() {
      const btn = document.getElementById("btn-lock-sam");
      if (btn.disabled) return;
      btn.disabled = true;
      const sample = await captureSmartSample();
      btn.disabled = false;
      if (!sample) return;
      savedSamLab = { ...sample.lab };
      updateCard("sam", savedSamLab, sample.rgb);
      document.getElementById("card-sam").classList.add("active-sam");
      flashTarget();
      tryCalculate();
      lucide.createIcons();
    }
    function flashTarget() {
      const tb = document.getElementById("target-box");
      tb.classList.remove("flash"); void tb.offsetWidth; tb.classList.add("flash");
    }
    function updateCard(type, lab, rgb) {
      document.getElementById(`preview-${type}`).style.background = rgb;
      document.getElementById(`${type}-l`).innerText = lab.L;
      document.getElementById(`${type}-a`).innerText = lab.a;
      document.getElementById(`${type}-b`).innerText = lab.b;
      const lVal = Math.max(0, Math.min(100, parseFloat(lab.L)));
      const marker = document.getElementById(`marker-${type}`);
      marker.classList.add("visible");
      marker.style.bottom = lVal + "%";
    }
    function resetAll() {
      savedRefLab = null; savedSamLab = null;
      refMetrics = null; liveMetrics = null;
      toggleCameraLock(false);
      ["ref", "sam"].forEach((type) => {
        document.getElementById(`card-${type}`).classList.remove("active-ref", "active-sam");
        document.getElementById(`preview-${type}`).style.background = "#334155";
        document.getElementById(`${type}-l`).innerText = "-";
        document.getElementById(`${type}-a`).innerText = "-";
        document.getElementById(`${type}-b`).innerText = "-";
        document.getElementById(`marker-${type}`).classList.remove("visible");
      });
      ghostOverlay.classList.remove("active");
      setTimeout(() => { ghostOverlay.src = ""; }, 300);
      document.getElementById("delta-val").innerText = "--";
      document.getElementById("result-dashboard").className = "result-dashboard";
      document.getElementById("delta-msg").innerText = "READY";
      document.getElementById("advice-content").innerHTML = "";
      document.getElementById("advice-placeholder").style.display = "flex";
      showGuidance(false);
      lucide.createIcons();
    }

    // --- TORCH ---
    async function setTorch(on) {
      if (!videoTrack || !torchSupported || !videoTrack.applyConstraints) return false;
      try { await videoTrack.applyConstraints({ advanced: [{ torch: !!on }] }); return true; } catch (e) { return false; }
    }
    function updateTorchUI() {
      const btn = document.getElementById("btn-torch");
      if (!btn) return;
      if (isTorchOn) {
        btn.innerHTML = '<i data-lucide="flashlight-off" style="width:18px;"></i>';
        btn.style.borderColor = "rgba(255,255,255,0.35)";
      } else {
        btn.innerHTML = '<i data-lucide="flashlight" style="width:18px;"></i>';
        btn.style.borderColor = "rgba(255,255,255,0.12)";
      }
      lucide.createIcons();
    }
    async function toggleTorchHold() {
      if (isTorchBusy) return;
      isTorchBusy = true;
      const next = !isTorchOn;
      try {
        if (torchSupported && videoTrack?.applyConstraints) {
          const ok = await setTorch(next);
          if (!ok && next) {
            document.body.classList.add("screen-lamp");
            isTorchOn = true;
            updateTorchUI();
            return;
          }
          isTorchOn = next;
          if (!isTorchOn) document.body.classList.remove("screen-lamp");
          updateTorchUI();
          return;
        }
        isTorchOn = next;
        document.body.classList.toggle("screen-lamp", isTorchOn);
        updateTorchUI();
      } finally { isTorchBusy = false; }
    }

    // --- CALC ---
    function tryCalculate() {
      if (savedRefLab && savedSamLab) {
        let samForCalc = { ...savedSamLab };
        let refL = parseFloat(savedRefLab.L);
        let samL = parseFloat(savedSamLab.L);
        let diffL = samL - refL;
        const TEXTURE_MODE = true;
        if (TEXTURE_MODE) {
          if (diffL < 0) {
            const DAMPEN_FACTOR = 0.3;
            samForCalc.L = (refL + (diffL * DAMPEN_FACTOR)).toFixed(1);
          }
        }
        let dE = 0;
        if (deltaMode === "2000") dE = calculateDeltaE2000(savedRefLab, samForCalc);
        else if (deltaMode === "94") dE = calculateDeltaE94(savedRefLab, samForCalc);
        else dE = calculateDeltaE76(savedRefLab, samForCalc);
        const dash = document.getElementById("result-dashboard");
        document.getElementById("delta-val").innerText = dE.toFixed(2);
        dash.classList.remove("status-match", "status-close", "status-diff");
        if (dE <= 1.0) { dash.classList.add("status-match"); document.getElementById("delta-msg").innerText = "EXACT"; }
        else if (dE <= 2.5) { dash.classList.add("status-close"); document.getElementById("delta-msg").innerText = "CLOSE"; }
        else { dash.classList.add("status-diff"); document.getElementById("delta-msg").innerText = "DIFF"; }
        generateAdvice(savedRefLab, samForCalc);
      }
    }
    function generateAdvice(ref, curr) {
      const dL = parseFloat(ref.L) - parseFloat(curr.L);
      const da = parseFloat(ref.a) - parseFloat(curr.a);
      const db = parseFloat(ref.b) - parseFloat(curr.b);
      const th = 1.0;
      const container = document.getElementById("advice-content");
      const placeholder = document.getElementById("advice-placeholder");
      container.innerHTML = "";
      let actions = [];
      if (dL > th) actions.push({ icon: "sun", text: "Lighten", det: "+White", col: "#fff" });
      else if (dL < -th) actions.push({ icon: "moon", text: "Darken", det: "+Black", col: "#94a3b8" });
      if (da > th) actions.push({ icon: "droplet", text: "Add Red", det: "+Red", col: "#f87171" });
      else if (da < -th) actions.push({ icon: "droplet", text: "Add Green", det: "+Grn", col: "#4ade80" });
      if (db > th) actions.push({ icon: "droplet", text: "Add Yellow", det: "+Yel", col: "#facc15" });
      else if (db < -th) actions.push({ icon: "droplet", text: "Add Blue", det: "+Blu", col: "#60a5fa" });
      if (actions.length === 0) actions.push({ icon: "check-circle", text: "Perfect", det: "Good Match", col: "#10b981" });
      placeholder.style.display = "none";
      actions.forEach((a) => {
        const div = document.createElement("div");
        div.className = "advice-item";
        div.innerHTML = `<div class="adv-icon-row" style="color:${a.col}"><i data-lucide="${a.icon}" width="14"></i> ${a.text}</div><div class="adv-detail">${a.det}</div>`;
        container.appendChild(div);
      });
      lucide.createIcons();
    }
    function drawABGraph() {
      const w = plotCanvas.width, h = plotCanvas.height;
      const cx = w / 2, cy = h / 2;
      if (bgImageData) plotCtx.putImageData(bgImageData, 0, 0); else plotCtx.clearRect(0, 0, w, h);
      if (savedRefLab) drawDot(savedRefLab, "#000", "#3b82f6");
      if (savedSamLab) drawDot(savedSamLab, "#000", "#ffffff");
      if (savedRefLab && savedSamLab) {
        const rx = cx + parseFloat(savedRefLab.a), ry = cy - parseFloat(savedRefLab.b);
        const sx = cx + parseFloat(savedSamLab.a), sy = cy - parseFloat(savedSamLab.b);
        plotCtx.beginPath(); plotCtx.strokeStyle = "rgba(0,0,0,0.5)"; plotCtx.lineWidth = 1; plotCtx.setLineDash([2, 2]);
        plotCtx.moveTo(rx, ry); plotCtx.lineTo(sx, sy); plotCtx.stroke(); plotCtx.setLineDash([]);
      }
    }
    function drawDot(lab, stroke, fill) {
      const cx = plotCanvas.width/2, cy = plotCanvas.height/2;
      const x = cx + parseFloat(lab.a), y = cy - parseFloat(lab.b);
      plotCtx.beginPath(); plotCtx.fillStyle = fill; plotCtx.arc(x, y, 6, 0, Math.PI * 2); plotCtx.fill();
      plotCtx.lineWidth = 2; plotCtx.strokeStyle = stroke; plotCtx.stroke();
    }
    function changeMode(m) { deltaMode = m; document.getElementById("algo-lbl").innerText = m; tryCalculate(); }
    function renderColorMap() {
      const w = plotCanvas.width, h = plotCanvas.height;
      const cx = w / 2, cy = h / 2;
      const imgData = plotCtx.createImageData(w, h);
      const d = imgData.data;
      const maxDist = Math.min(w, h) / 2;
      for (let y = 0; y < h; y += 2) {
        for (let x = 0; x < w; x += 2) {
          const dx = x - cx, dy = y - cy;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const normDist = Math.min(1, dist / maxDist);
          const angleRad = Math.atan2(-dy, dx);
          let angleDeg = angleRad * (180 / Math.PI); if (angleDeg < 0) angleDeg += 360;
          const rgb = hslToRgb(angleDeg, normDist * 100, 100 - normDist * 55);
          const idx = (y * w + x) * 4;
          const setPx = (i) => { d[i]=rgb.r; d[i+1]=rgb.g; d[i+2]=rgb.b; d[i+3]=255; };
          if(idx<d.length) setPx(idx);
          if(((y+1)*w+(x+1))*4 < d.length) setPx(((y+1)*w+(x+1))*4);
        }
      }
      for (let x=0; x<w; x++) { const idx=(Math.floor(cy)*w+x)*4; d[idx]=255; d[idx+1]=255; d[idx+2]=255; d[idx+3]=40; }
      for (let y=0; y<h; y++) { const idx=(y*w+Math.floor(cx))*4; d[idx]=255; d[idx+1]=255; d[idx+2]=255; d[idx+3]=40; }
      bgImageData = imgData;
    }
    function hslToRgb(h, s, l) {
      s/=100; l/=100;
      const k = (n) => (n + h/30)%12;
      const a = s * Math.min(l, 1-l);
      const f = (n) => l - a * Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n), 1)));
      return { r:Math.round(255*f(0)), g:Math.round(255*f(8)), b:Math.round(255*f(4)) };
    }
    function rgbToLab(r, g, b) {
      let R=r/255, G=g/255, B=b/255;
      R=(R>0.04045)?Math.pow((R+0.055)/1.055,2.4):R/12.92;
      G=(G>0.04045)?Math.pow((G+0.055)/1.055,2.4):G/12.92;
      B=(B>0.04045)?Math.pow((B+0.055)/1.055,2.4):B/12.92;
      let X=(R*0.4124+G*0.3576+B*0.1805)*100, Y=(R*0.2126+G*0.7152+B*0.0722)*100, Z=(R*0.0193+G*0.1192+B*0.9505)*100;
      X/=95.047; Y/=100.000; Z/=108.883;
      X=(X>0.008856)?Math.pow(X,1/3):(7.787*X)+16/116;
      Y=(Y>0.008856)?Math.pow(Y,1/3):(7.787*Y)+16/116;
      Z=(Z>0.008856)?Math.pow(Z,1/3):(7.787*Z)+16/116;
      return { L:((116*Y)-16).toFixed(1), a:(500*(X-Y)).toFixed(1), b:(200*(Y-Z)).toFixed(1) };
    }
    function calculateDeltaE76(l1,l2){ return Math.sqrt(Math.pow(l2.L-l1.L,2)+Math.pow(l2.a-l1.a,2)+Math.pow(l2.b-l1.b,2)); }
    function calculateDeltaE94(l1,l2){
      const L1=parseFloat(l1.L), a1=parseFloat(l1.a), b1=parseFloat(l1.b);
      const L2=parseFloat(l2.L), a2=parseFloat(l2.a), b2=parseFloat(l2.b);
      const C1=Math.sqrt(a1**2+b1**2), C2=Math.sqrt(a2**2+b2**2);
      const dL=L1-L2, dC=C1-C2, da=a1-a2, db=b1-b2;
      const dH=Math.sqrt(Math.max(0, da**2+db**2-dC**2));
      const SC=1+0.045*C1, SH=1+0.015*C1;
      return Math.sqrt(dL**2+(dC/SC)**2+(dH/SH)**2);
    }
    function calculateDeltaE2000(l1,l2){
      const L1=parseFloat(l1.L),a1=parseFloat(l1.a),b1=parseFloat(l1.b);
      const L2=parseFloat(l2.L),a2=parseFloat(l2.a),b2=parseFloat(l2.b);
      const deg2rad=d=>d*Math.PI/180, rad2deg=r=>r*180/Math.PI;
      const C1=Math.sqrt(a1**2+b1**2), C2=Math.sqrt(a2**2+b2**2), avgC=(C1+C2)/2;
      const G=0.5*(1-Math.sqrt(avgC**7/(avgC**7+25**7)));
      const a1p=(1+G)*a1, a2p=(1+G)*a2;
      const C1p=Math.sqrt(a1p**2+b1**2), C2p=Math.sqrt(a2p**2+b2**2);
      const h1p=(a1p===0&&b1===0)?0:rad2deg(Math.atan2(b1,a1p))+(rad2deg(Math.atan2(b1,a1p))<0?360:0);
      const h2p=(a2p===0&&b2===0)?0:rad2deg(Math.atan2(b2,a2p))+(rad2deg(Math.atan2(b2,a2p))<0?360:0);
      const dLp=L2-L1, dCp=C2p-C1p;
      let dhp=0; if(C1p*C2p!==0) dhp=(Math.abs(h2p-h1p)<=180)?h2p-h1p:(h2p-h1p>180?h2p-h1p-360:h2p-h1p+360);
      const dHp=2*Math.sqrt(C1p*C2p)*Math.sin(deg2rad(dhp/2));
      const avgLp=(L1+L2)/2, avgCp=(C1p+C2p)/2;
      let avghp=0; if(C1p*C2p!==0) avghp=(Math.abs(h1p-h2p)<=180)?(h1p+h2p)/2:((h1p+h2p<360)?(h1p+h2p+360)/2:(h1p+h2p-360)/2);
      const T=1-0.17*Math.cos(deg2rad(avghp-30))+0.24*Math.cos(deg2rad(2*avghp))+0.32*Math.cos(deg2rad(3*avghp+6))-0.20*Math.cos(deg2rad(4*avghp-63));
      const SL=1+((0.015*(avgLp-50)**2)/Math.sqrt(20+(avgLp-50)**2)), SC=1+0.045*avgCp, SH=1+0.015*avgCp*T;
      const dTheta = 30 * Math.exp( -Math.pow((avghp-275)/25, 2) );
      const RC=2*Math.sqrt(avgCp**7/(avgCp**7+25**7)), RT=-Math.sin(deg2rad(2*dTheta))*RC;
      return Math.sqrt((dLp/SL)**2+(dCp/SC)**2+(dHp/SH)**2+RT*(dCp/SC)*(dHp/SH));
    }

    function applyAutoFitLayout() {
      const frame=document.querySelector(".app-frame"), header=document.querySelector("header");
      if(!frame||!header)return;
      const H=frame.getBoundingClientRect().height, headerH=header.offsetHeight;
      const tabH = 60;
      const remain=Math.max(0, H-headerH-tabH);
      const viewportH=Math.max(120,Math.min(270,Math.round(remain*0.34)));
      const panelRemain=Math.max(0, remain-viewportH);
      const vizH=Math.max(76,Math.min(175,Math.round(panelRemain*0.24)));
      const gap=Math.max(10,Math.min(18,Math.round(panelRemain*0.06)));
      document.documentElement.style.setProperty("--viewport-h",viewportH+"px");
      document.documentElement.style.setProperty("--viz-h",vizH+"px");
      document.documentElement.style.setProperty("--gap-layout",gap+"px");
      requestAnimationFrame(resizeGraph);
    }

    applyAutoFitLayout();
    setCompactMode();

    const frameEl=document.querySelector(".app-frame");
    if(frameEl && "ResizeObserver" in window) new ResizeObserver(()=>{ applyAutoFitLayout(); setCompactMode(); }).observe(frameEl);

    document.addEventListener("visibilitychange", async()=>{
      if(document.hidden && isTorchOn){
        if(torchSupported) await setTorch(false);
        document.body.classList.remove("screen-lamp");
        isTorchOn=false;
        updateTorchUI();
      }
    });
    window.addEventListener("beforeunload", async()=>{ if(torchSupported) await setTorch(false); });

    initCamera();
  </script>
</body>
</html>