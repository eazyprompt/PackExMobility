<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
  />
  <title>PackEx</title>

  <link rel="icon" type="image/png" sizes="32x32" href="/PackExMobility/favicon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/PackExMobility/favicon-16.png">

  <link rel="apple-touch-icon" sizes="180x180" href="/PackExMobility/icon-180.png">
  <link rel="apple-touch-icon" sizes="167x167" href="/PackExMobility/icon-167.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/PackExMobility/icon-152.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/PackExMobility/icon-120.png">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#020617">

  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;800&family=JetBrains+Mono:wght@500;700;800&display=swap"
    rel="stylesheet"
  />
  <script src="https://cdn.jsdelivr.net/npm/lucide@0.321.0/dist/umd/lucide.min.js"></script>

  <style>
    :root {
      --bg-body: #0f172a;
      --bg-card: #1e293b;
      --bg-sidebar: #172554;
      --border-subtle: rgba(255, 255, 255, 0.12);
      --text-main: #ffffff;
      --text-muted: #94a3b8;
      --primary: #3b82f6;
      --primary-glow: rgba(59, 130, 246, 0.5);
      --sample: #ffffff;
      --success: #34d399;
      --warn: #fbbf24;
      --danger: #ef4444;
      --radius-lg: 18px;
      --font-ui: "Inter", sans-serif;
      --font-num: "JetBrains Mono", monospace;

      --frame-gap: clamp(14px, 5.5vw, 60px);
      --gap-layout: 16px;

      --viewport-h: 220px;
      --viz-h: 150px;
      --app-h: 100dvh;
      --tab-h: 60px;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }

    body {
      background: #020617;
      color: var(--text-main);
      font-family: var(--font-ui);
      margin: 0;
      width: 100vw;
      height: var(--app-h);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    body::after{
      content:""; position: fixed; inset: 0; background: rgba(255,255,255,0.85);
      opacity: 0; pointer-events: none; transition: opacity 120ms ease; z-index: 9999;
    }
    body.screen-flash::after{ opacity: 1; }
    body.screen-lamp::after{ opacity: 1; }

    .app-frame {
      width: calc(100vw - (var(--frame-gap) * 2));
      height: calc(var(--app-h) - (var(--frame-gap) * 2));
      max-width: 500px;
      max-height: calc(var(--app-h) - (var(--frame-gap) * 2));
      background: var(--bg-body);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
      border-radius: 24px;
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.6), 0 0 0 1px var(--border-subtle);
      padding-top: env(safe-area-inset-top);
      padding-bottom: 0;
    }

    header {
      min-height: 64px;
      padding: 0 20px;
      padding-top: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--bg-body);
      border-bottom: 1px solid var(--border-subtle);
      flex-shrink: 0;
      z-index: 50;
      gap: 10px;
      min-width: 0;
    }

    .brand {
      font-weight: 800; font-size: 1.25rem; display: flex; align-items: center; gap: 10px; color: #fff;
      min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .brand i { color: var(--primary); }
    .brand span { color: var(--primary); font-weight: 400; opacity: 0.9; font-size: 0.8em; }
    .header-controls { display: flex; align-items: center; gap: 10px; min-width: 0; }
    .algo-selector {
      appearance: none; background: #334155; color: #fff; border: 1px solid var(--border-subtle);
      padding: 8px 14px; border-radius: 100px; font-size: 0.75rem; font-weight: 600;
      font-family: var(--font-num); transition: 0.2s; min-width: 0; max-width: 160px;
    }
    .btn-icon-header {
      background: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-subtle); color: #fff;
      width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
      cursor: pointer; transition: 0.2s; flex-shrink: 0;
    }

    .viewport {
      height: var(--viewport-h);
      min-height: 0;
      display: flex;
      background: #020617;
      border-bottom: 1px solid var(--border-subtle);
      flex-shrink: 0;
      position: relative;
      transition: height 0.3s ease;
    }
    .vp-camera {
      flex: 1; position: relative; overflow: hidden; display: flex;
      align-items: center; justify-content: center; border-right: 1px solid var(--border-subtle);
      background: #020617; min-width: 0;
      transition: flex 0.3s ease;
    }
    .vp-camera.full-width { border-right: none; }

    video { width: 100%; height: 100%; object-fit: cover; opacity: 1.0; position: relative; z-index: 1; }
    .ghost-overlay {
      position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover;
      opacity: 0; pointer-events: none; z-index: 5; transition: opacity 0.3s ease; filter: grayscale(0.2);
    }
    .ghost-overlay.active { opacity: 0.35; }
    #sheet-canvas {
      position: absolute; inset:0; width:100%; height:100%;
      pointer-events:none; z-index: 20;
    }

    .vp-side-panel {
      flex: 1; background: var(--bg-sidebar); display: flex; flex-direction: column;
      padding: 16px; overflow-y: auto; flex-shrink: 0;
      box-shadow: inset 5px 0 15px rgba(0, 0, 0, 0.2); min-width: 0;
      transition: width 0.3s ease, flex 0.3s ease;
    }
    .vp-side-panel.hidden { display: none; }

    .vp-header {
      font-size: 0.7rem; font-weight: 800; color: #60a5fa;
      text-transform: uppercase; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;
    }
    .advice-item {
      background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px; padding: 12px; margin-bottom: 10px; animation: slideIn 0.3s ease;
    }
    .adv-icon-row { display: flex; align-items: center; gap: 8px; font-size: 0.8rem; font-weight: 700; color: #fff; margin-bottom: 4px; }
    .adv-detail { font-size: 0.7rem; color: var(--text-muted); margin-left: 2px; }
    @keyframes slideIn { from { opacity: 0; transform: translateX(10px); } to { opacity: 1; transform: translateX(0); } }

    .hud-overlay {
      position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
      pointer-events: none; z-index: 10;
    }

    .target-box {
      width: 42px; height: 42px; position: relative;
      box-shadow: 0 0 0 100vmax rgba(2, 6, 23, 0.6);
      border-radius: 12px; transition: transform 0.1s;
    }
    .target-box::before {
      content: ""; position: absolute; inset: -1px;
      border: 2px solid rgba(255, 255, 255, 0.9); border-radius: 12px;
    }
    .target-box.flash { transform: scale(0.95); }
    .target-box.flash::before { border-color: var(--primary); box-shadow: 0 0 25px var(--primary); }
    .crosshair { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; opacity: 0.8; }
    .ch-c { width: 4px; height: 4px; background: #fff; border-radius: 50%; box-shadow: 0 0 2px #000; }

    .panel {
      flex: 1;
      background: var(--bg-body);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      padding: 0;
      min-height: 0;
    }

    .panel-content {
      display: flex; flex-direction: column; gap: var(--gap-layout);
      margin: 0 auto; width: 100%; height: 100%; min-height: 0;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      padding-bottom: calc(var(--tab-h) + env(safe-area-inset-bottom) + 12px);
    }

    /* GLUE */
    .glue-dashboard {
      display:flex; flex-direction:column;
      height:100%; min-height: 400px;
      background:#0f172a;
      overflow:hidden;
      width:100%;
    }
    .glue-body-split {
      flex: 1;
      display: flex;
      flex-direction: row;
      overflow: hidden;
      position: relative;
    }
    .glue-main-area {
      flex: 7;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: #020617;
      border-right: 1px solid var(--border-subtle);
    }
    .glue-summary-area {
      flex: 3;
      background: #172554;
      display: flex;
      flex-direction: column;
      padding: 16px 12px;
      gap: 16px;
      overflow-y: auto;
      padding-bottom: calc(var(--tab-h) + env(safe-area-inset-bottom) + 10px);
    }
    .sum-item {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      gap: 4px;
    }
    .sum-lbl { font-size: 0.55rem; color: #94a3b8; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }
    .sum-val { font-family: var(--font-num); font-size: 1.4rem; font-weight: 800; color: #fff; line-height: 1; }
    .text-ok { color: var(--success); }
    .text-ng { color: var(--danger); }

    .btn-header-cap {
      width: 44px; height: 44px;
      border-radius: 12px;
      background: #3b82f6;
      color: #fff;
      border: none;
      display: flex; align-items: center; justify-content: center;
      font-size: 1.2rem;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
      transition: 0.2s;
    }
    .btn-header-cap:active { transform: scale(0.92); }
    .btn-header-cap.frozen {
      background: #ef4444;
      box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
    }

    .glue-compact-header{
      background: rgba(15, 23, 42, 0.98);
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding: 10px 16px;
      display:flex; justify-content:space-between; align-items:center;
      flex-shrink:0; z-index:10;
    }
    .gc-left { display:flex; align-items:center; gap:10px; }
    .gc-right { display:flex; align-items:center; gap:14px; }
    .gc-status-badge{
      padding: 6px 12px; border-radius: 6px; font-size: 0.75rem; font-weight: 800;
      display:flex; align-items:center; gap:6px; letter-spacing:0.5px;
      background:#1e293b; border:1px solid rgba(255,255,255,0.1); color:#94a3b8;
    }
    .status-pass .gc-status-badge{ background: rgba(16,185,129,0.1); color:#34d399; border-color: rgba(52,211,153,0.2); }
    .status-fail .gc-status-badge{ background: rgba(239,68,68,0.1); color:#f87171; border-color: rgba(248,113,113,0.2); }

    .glue-list-header {
      padding: 12px 16px;
      background: #0f172a;
      border-bottom: 1px solid var(--border-subtle);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      flex-shrink: 0;
    }
    .stat-box {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 8px 10px;
      display: flex; flex-direction: column; gap: 2px;
    }
    .stat-title { font-size: 0.6rem; color: #64748b; font-weight: 700; text-transform: uppercase; }
    .stat-val { font-family: var(--font-num); font-size: 1.1rem; color: #fff; font-weight: 700; }
    .stat-unit { font-size: 0.7em; color: #64748b; font-weight: 500; margin-left: 2px; }

    .dist-container {
      flex: 1;
      position: relative;
      display: flex;
      flex-direction: column;
      padding: 10px;
      overflow: hidden;
      background: #020617;
    }
    #dist-canvas { width: 100%; height: 100%; display: block; }

    canvas { display:block; }
    #proc-canvas { display:none; }

    .result-dashboard { /* colex */ display:none; } /* (colex section below will override via JS show/hide) */

    .tab-bar {
      position: absolute; bottom: 0; left: 0; right: 0; height: var(--tab-h);
      background: rgba(15, 23, 42, 0.9); backdrop-filter: blur(10px);
      border-top: 1px solid var(--border-subtle); display: flex;
      justify-content: space-around; align-items: center; z-index: 100;
      padding-bottom: env(safe-area-inset-bottom);
    }
    .tab-item {
      flex: 1; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: var(--text-muted); gap: 4px; cursor: pointer; transition: 0.2s;
    }
    .tab-item.active { color: var(--primary); }
    .tab-lbl { font-size: 0.65rem; font-weight: 700; }
    .display-none { display: none !important; }

    /* Bigger bottom-tab icons + labels */
    .tab-bar .tab-item svg{ width: 26px; height: 26px; stroke-width: 2.4; }
    .tab-bar .tab-lbl{ font-size: 0.72rem; font-weight: 800; }
    .tab-bar{ height: 66px; padding-top: 6px; padding-bottom: calc(env(safe-area-inset-bottom) + 2px); }
    @media (display-mode: standalone) {
      .tab-bar .tab-item svg{ width: 30px; height: 30px; stroke-width: 2.6; }
      .tab-bar .tab-lbl{ font-size: 0.75rem; font-weight: 800; line-height: 1; }
      .tab-bar{ height: 68px; padding-top: 6px; padding-bottom: calc(env(safe-area-inset-bottom) + 4px); }
    }
  </style>
</head>

<body>
  <div class="app-frame">
    <header>
      <div class="brand"><i data-lucide="scan-face"></i> PackEx <span>Mobility</span></div>
      <div class="header-controls">
        <div id="ctl-color-algo">
          <select id="algo-select" class="algo-selector" onchange="changeMode(this.value)">
            <option value="2000">DE 2000</option>
            <option value="94">DE 94</option>
            <option value="76">DE 76</option>
          </select>
        </div>
        <button class="btn-icon-header" id="btn-torch" onclick="toggleTorchHold()" title="Torch">
          <i data-lucide="flashlight" style="width: 18px;"></i>
        </button>
      </div>
    </header>

    <div class="viewport">
      <div class="vp-camera" id="vp-camera">
        <video id="webcam" autoplay playsinline muted></video>
        <img id="ghost-overlay" class="ghost-overlay" src="" alt="Ghost Reference" />
        <canvas id="sheet-canvas"></canvas>

        <div class="hud-overlay">
          <div id="target-box" class="target-box">
            <div class="crosshair"><div class="ch-c"></div></div>
          </div>
        </div>
      </div>

      <div class="vp-side-panel" id="vp-side-panel">
        <div id="side-colex">
          <div class="vp-header"><i data-lucide="bot" style="width: 14px;"></i> AI ASSIST</div>
          <div id="advice-content"></div>
          <div id="advice-placeholder" style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; opacity:0.35; text-align:center; gap:10px; color:#94a3b8;">
            <i data-lucide="scan" style="width: 28px; opacity: 0.55;"></i>
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="panel-content">

        <!-- COLEX PANEL (kept from previous; minimal for this message) -->
        <div id="panel-colex" style="display:flex; flex-direction:column; gap:var(--gap-layout); padding: 10px 20px;">
          <div id="result-dashboard" class="result-dashboard" style="display:flex; gap:12px; justify-content:space-between; align-items:center; background: linear-gradient(145deg, #1e293b 0%, #0f172a 100%); border: 1px solid var(--border-subtle); border-radius: 18px; padding: 14px 16px;">
            <div style="display:flex; flex-direction:column; gap:2px;">
              <div style="font-size:0.65rem; color:#94a3b8; font-weight:700; text-transform:uppercase;">Delta E <span id="algo-lbl">2000</span></div>
              <div style="font-family: var(--font-num); font-size: 2.2rem; font-weight: 800;" id="delta-val">--</div>
            </div>
            <div style="display:flex; align-items:center; gap:10px;">
              <div style="padding:8px 14px; border-radius: 10px; font-size:0.75rem; font-weight: 800; background:#334155; border:1px solid rgba(255,255,255,0.1);" id="delta-msg">READY</div>
              <button class="btn-icon-header" onclick="resetAll()" title="Reset">
                <i data-lucide="rotate-cw" style="width: 18px;"></i>
              </button>
            </div>
          </div>

          <div style="opacity:0.5; font-size:0.8rem;">(COLEX UI ยังคงเดิม — โฟกัสแก้ GLUE GAP ในข้อความนี้)</div>
        </div>

        <!-- GLUE GAP PANEL -->
        <div id="panel-gluegap" class="display-none" style="height:100%; width:100%;">
          <div class="glue-dashboard">
            <div class="glue-compact-header" id="glue-header">
              <div class="gc-left" id="header-status-group">
                <div class="gc-status-badge"><i data-lucide="minus"></i> READY</div>
              </div>

              <div class="gc-right">
                <button id="btn-sheet-cap" class="btn-header-cap" onclick="toggleSheetCapture()">
                  <i data-lucide="camera"></i>
                </button>
              </div>
            </div>

            <div class="glue-body-split">
              <div class="glue-main-area" id="layer-list-cont">
                <div class="glue-list-header" id="stats-header" style="display:none;"></div>

                <div class="dist-container" id="dist-wrapper">
                  <canvas id="dist-canvas"></canvas>
                  <div id="empty-scan-msg" style="position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; color:#475569; gap:10px;">
                    <i data-lucide="scan-line" width="32"></i>
                    <span style="font-size:0.75rem;">Align camera to scan</span>
                  </div>
                </div>
              </div>

              <div class="glue-summary-area">
                <div class="sum-item">
                  <div class="sum-val" id="sum-total">0</div>
                  <div class="sum-lbl">Box Found</div>
                </div>
                <div class="sum-item">
                  <div class="sum-val text-ok" id="sum-gap">0</div>
                  <div class="sum-lbl">Glue Gap</div>
                </div>
                <div class="sum-item">
                  <div class="sum-val text-ng" id="sum-ng">0</div>
                  <div class="sum-lbl">No Gap</div>
                </div>
              </div>
            </div>

          </div>
        </div>

      </div>
    </div>

    <div class="tab-bar">
      <div class="tab-item active" id="tab-colex" onclick="switchTab('colex')">
        <i data-lucide="palette"></i>
        <span class="tab-lbl">COLEX</span>
      </div>
      <div class="tab-item" id="tab-gluegap" onclick="switchTab('gluegap')">
        <i data-lucide="layers"></i>
        <span class="tab-lbl">GLUE GAP</span>
      </div>
    </div>

  </div>

  <canvas id="proc-canvas" width="100" height="100"></canvas>

  <script>
    lucide.createIcons();

    // ===========================
    // TUNING (ปรับง่ายตรงนี้)
    // ===========================
    const TUNE = {
      DEBUG_LABEL: false,       // true = โชว์ score/contrast บน label
      // Box detection
      STRIPS: [                 // หลายแถบแนวตั้ง (กันโพรงตรงกลาง)
        [0.18, 0.30],
        [0.44, 0.56],
        [0.70, 0.82],
      ],
      EDGE_SKIP_DARK: 38,       // ข้ามพิกเซลมืดมาก (โพรง) ตอนหา edge
      BAND_THR_FLOOR: 0.18,     // threshold floor (ยิ่งต่ำยิ่งจับได้มาก)
      BAND_MINLEN_FRAC: 0.045,  // band ขั้นต่ำเป็นสัดส่วนของความสูง ROI

      // Gap detection
      GAP_XL: 0.18,
      GAP_XR: 0.82,
      SHOULDER_WIN: 10,         // จำนวน sample รอบๆ valley เพื่อคำนวณ shoulder
      GAP_CENTER_ALLOW: 0.36,   // อนุญาตให้ gap อยู่ห่างจาก center ได้กว้างขึ้น
      MIN_CONTRAST: 6.0,        // ลดลงจากเดิมเพื่อสภาพจริง
      RUN_FRAC: 0.10,           // run ขั้นต่ำเป็นสัดส่วน bandW
      SCORE_THR: 0.42,          // threshold ตัดสินว่าเป็น Gap (ลดลง)
      GRAY_LO: 0.38,            // hysteresis zone
      GRAY_HI: 0.50
    };

    // --- GLOBALS ---
    const video = document.getElementById("webcam");
    const procCanvas = document.getElementById("proc-canvas");
    const procCtx = procCanvas.getContext("2d", { willReadFrequently: true });

    const distCanvas = document.getElementById("dist-canvas");
    const distCtx = distCanvas.getContext("2d");

    const sheetCanvas = document.getElementById("sheet-canvas");
    const sheetCtx = sheetCanvas.getContext("2d");

    const ghostOverlay = document.getElementById("ghost-overlay");

    let activeTab = 'colex';
    let isProcessing = false;

    let savedRefLab = null, savedSamLab = null;

    let videoTrack = null;
    let torchSupported = false;
    let isTorchOn = false;
    let torchOpBusy = false;
    let captureBusy = false;

    let sheetFrozen = false;

    // Stabilizers
    let layerStabilizer = new Map();
    let gapStabilizer = new Map();

    // --- helpers ---
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function lerp(a, b, t) { return (1 - t) * a + t * b; }
    function wait(ms) { return new Promise((r) => setTimeout(r, ms)); }

    // =========================================================
    // COVER-MAPPING
    // =========================================================
    function getCoverMetrics() {
      const vw = video.videoWidth || 0;
      const vh = video.videoHeight || 0;
      if (!vw || !vh) return null;

      const r = video.getBoundingClientRect();
      const dw = r.width || 0;
      const dh = r.height || 0;
      if (!dw || !dh) return null;

      const scale = Math.max(dw / vw, dh / vh);
      const scaledW = vw * scale;
      const scaledH = vh * scale;
      const offX = (dw - scaledW) / 2;
      const offY = (dh - scaledH) / 2;

      return { vw, vh, dw, dh, scale, offX, offY, rect: r };
    }

    function dispToVideoXY(mx, my, m) {
      const x = (mx - m.offX) / m.scale;
      const y = (my - m.offY) / m.scale;
      return { x, y };
    }

    function dispRectToVideoRect(rx, ry, rw, rh, m) {
      const p0 = dispToVideoXY(rx, ry, m);
      const p1 = dispToVideoXY(rx + rw, ry + rh, m);

      let x = Math.min(p0.x, p1.x);
      let y = Math.min(p0.y, p1.y);
      let w = Math.abs(p1.x - p0.x);
      let h = Math.abs(p1.y - p0.y);

      x = clamp(x, 0, m.vw - 1);
      y = clamp(y, 0, m.vh - 1);
      w = clamp(w, 1, m.vw - x);
      h = clamp(h, 1, m.vh - y);

      return { x, y, w, h };
    }

    function syncSheetCanvasToDisplay() {
      const m = getCoverMetrics();
      if (!m) return;
      const nw = Math.max(1, Math.round(m.dw));
      const nh = Math.max(1, Math.round(m.dh));
      if (sheetCanvas.width !== nw || sheetCanvas.height !== nh) {
        sheetCanvas.width = nw;
        sheetCanvas.height = nh;
        sheetCtx.clearRect(0, 0, nw, nh);
      }
    }

    // --- LAYOUT ---
    function applyAutoFitLayout() {
      const frame = document.querySelector(".app-frame");
      if (!frame) return;

      const vvH = window.visualViewport ? window.visualViewport.height : window.innerHeight;
      document.documentElement.style.setProperty("--app-h", `${Math.round(vvH)}px`);

      const frameH = frame.offsetHeight;

      if (activeTab === 'gluegap') {
        const camH = Math.round(frameH * 0.50);
        document.documentElement.style.setProperty("--viewport-h", `${camH}px`);

        const wrap = document.getElementById("dist-wrapper");
        if (wrap && wrap.offsetWidth) {
          distCanvas.width = wrap.offsetWidth;
          distCanvas.height = wrap.offsetHeight;
        }
      } else {
        const camH = Math.round(frameH * 0.38);
        document.documentElement.style.setProperty("--viewport-h", `${Math.max(200, camH)}px`);
      }

      syncSheetCanvasToDisplay();
    }
    window.addEventListener("resize", applyAutoFitLayout);
    if (window.visualViewport) window.visualViewport.addEventListener("resize", applyAutoFitLayout);
    applyAutoFitLayout();

    // --- TABS ---
    function switchTab(mode) {
      activeTab = mode;
      document.querySelectorAll('.tab-item').forEach(el => el.classList.remove('active'));
      document.getElementById(`tab-${mode}`).classList.add('active');

      document.getElementById('panel-colex').style.display = 'none';
      document.getElementById('panel-gluegap').classList.add('display-none');

      document.getElementById('vp-side-panel').classList.add('hidden');
      document.getElementById('vp-camera').classList.add('full-width');
      document.getElementById('ctl-color-algo').classList.add('display-none');

      sheetCtx.clearRect(0, 0, sheetCanvas.width, sheetCanvas.height);
      document.getElementById('target-box').classList.add('display-none');

      if (mode === 'colex') {
        document.getElementById('ctl-color-algo').classList.remove('display-none');
        document.getElementById('vp-side-panel').classList.remove('hidden');
        document.getElementById('vp-camera').classList.remove('full-width');
        document.getElementById('panel-colex').style.display = 'flex';
        document.getElementById('target-box').classList.remove('display-none');
      } else {
        ghostOverlay.classList.remove("active");
        setTimeout(() => { ghostOverlay.src = ""; }, 0);
        document.getElementById('panel-gluegap').classList.remove('display-none');
        document.getElementById('panel-gluegap').style.display = 'flex';
        resetSheetUI();
      }

      const pc = document.querySelector('.panel-content');
      if (pc) pc.scrollTop = 0;

      applyAutoFitLayout();
      lucide.createIcons();
    }

    // --- CAMERA ---
    async function initCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } },
        });
        video.srcObject = stream;
        videoTrack = stream.getVideoTracks?.()[0] || null;

        try {
          const caps = videoTrack?.getCapabilities?.();
          torchSupported = !!caps?.torch;
        } catch (e) { torchSupported = false; }

        updateTorchUI();

        video.onloadedmetadata = () => {
          syncSheetCanvasToDisplay();
          applyAutoFitLayout();
          isProcessing = true;
          requestAnimationFrame(loop);
        };
      } catch (err) {
        alert("Camera Error: " + err);
      }
    }

    function loop() {
      if (!isProcessing) return;
      if (activeTab === 'gluegap') syncSheetCanvasToDisplay();

      if (activeTab === 'gluegap') {
        processSheetFrame();
      }
      requestAnimationFrame(loop);
    }

    // =========================================================
    // SIGNAL UTILS
    // =========================================================
    function movingAverage(arr, radius) {
      const out = new Float32Array(arr.length);
      for (let i = 0; i < arr.length; i++) {
        let sum = 0, cnt = 0;
        for (let r = -radius; r <= radius; r++) {
          const j = i + r;
          if (j >= 0 && j < arr.length) { sum += arr[j]; cnt++; }
        }
        out[i] = cnt ? (sum / cnt) : arr[i];
      }
      return out;
    }

    function medianOfSorted(sorted) {
      const n = sorted.length;
      if (!n) return 0;
      const mid = (n / 2) | 0;
      return (n % 2) ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
    }

    function robustStats(arr) {
      const a = Array.from(arr);
      a.sort((x, y) => x - y);
      const med = medianOfSorted(a);
      const dev = a.map(v => Math.abs(v - med));
      dev.sort((x, y) => x - y);
      const mad = medianOfSorted(dev) || 0;
      return { med, mad };
    }

    // =========================================================
    // BOX DETECTION (FIXED: MULTI-STRIP MEDIAN)
    // =========================================================
    function lumaOf(data, i) {
      return data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
    }

    function extractEdgeProfileOneStrip(data, w, h, x0, x1) {
      const bandW = Math.max(1, x1 - x0);
      const prof = new Float32Array(h);

      for (let y = 1; y < h - 1; y++) {
        const rowM = (y - 1) * w * 4;
        const rowP = (y + 1) * w * 4;

        let s = 0;
        let cnt = 0;

        for (let x = x0; x < x1; x += 2) {
          const iM = rowM + x * 4;
          const iP = rowP + x * 4;

          const lM = lumaOf(data, iM);
          const lP = lumaOf(data, iP);

          // ข้ามพิกเซลมืดจัด (โพรง/เงาดำ) เพื่อไม่ให้พัง
          if (lM < TUNE.EDGE_SKIP_DARK && lP < TUNE.EDGE_SKIP_DARK) continue;

          s += Math.abs(lP - lM);
          cnt++;
        }

        // ถ้าข้ามเยอะเกิน ให้ fallback ใช้ทั้งหมด
        if (cnt < (bandW * 0.12)) {
          let s2 = 0;
          for (let x = x0; x < x1; x += 2) {
            const iM = rowM + x * 4;
            const iP = rowP + x * 4;
            s2 += Math.abs(lumaOf(data, iP) - lumaOf(data, iM));
          }
          prof[y] = s2 / Math.max(1, bandW / 2);
        } else {
          prof[y] = s / Math.max(1, cnt);
        }
      }

      // robust normalize to 0.. (z-like)
      const { med, mad } = robustStats(prof);
      const out = new Float32Array(h);
      const denom = Math.max(1e-6, mad * 2.2);
      for (let y = 0; y < h; y++) {
        out[y] = Math.max(0, (prof[y] - med) / denom);
      }
      return out;
    }

    function extractEdgeProfileMultiStrip(data, w, h) {
      const strips = TUNE.STRIPS.map(([a, b]) => {
        const x0 = clamp(Math.floor(w * a), 0, w - 2);
        const x1 = clamp(Math.floor(w * b), x0 + 1, w - 1);
        return extractEdgeProfileOneStrip(data, w, h, x0, x1);
      });

      const out = new Float32Array(h);
      for (let y = 0; y < h; y++) {
        const vals = strips.map(p => p[y]).sort((a, b) => a - b);
        out[y] = medianOfSorted(vals);
      }
      return out;
    }

    function findBoxBandsFromProfile(profile, h) {
      const smooth = movingAverage(profile, 8);
      const st = robustStats(smooth);

      const thr = Math.max(TUNE.BAND_THR_FLOOR, st.med + st.mad * 0.55);

      const active = new Uint8Array(h);
      for (let y = 0; y < h; y++) active[y] = smooth[y] > thr ? 1 : 0;

      // close small holes
      const maxHole = Math.max(8, Math.floor(h * 0.018));
      let run0 = -1;
      for (let y = 0; y < h; y++) {
        if (active[y] === 0 && run0 < 0) run0 = y;
        if (active[y] === 1 && run0 >= 0) {
          const holeLen = y - run0;
          if (holeLen <= maxHole) {
            for (let k = run0; k < y; k++) active[k] = 1;
          }
          run0 = -1;
        }
      }

      const bands = [];
      const minLen = Math.max(10, Math.floor(h * TUNE.BAND_MINLEN_FRAC));
      const topCut = Math.floor(h * 0.03);
      const botCut = Math.floor(h * 0.97);

      let y = 0;
      while (y < h) {
        while (y < h && active[y] === 0) y++;
        if (y >= h) break;
        const y0 = y;
        while (y < h && active[y] === 1) y++;
        const y1 = y - 1;

        if (y0 >= topCut && y1 <= botCut && (y1 - y0 + 1) >= minLen) {
          const cy = Math.round((y0 + y1) / 2);
          bands.push({ y0, y1, cy });
        }
      }

      // merge close bands
      const merged = [];
      const mergeGap = Math.max(8, Math.floor(h * 0.02));
      for (const b of bands) {
        const last = merged[merged.length - 1];
        if (last && (b.y0 - last.y1) <= mergeGap) {
          last.y1 = b.y1;
          last.cy = Math.round((last.y0 + last.y1) / 2);
        } else {
          merged.push({ ...b });
        }
      }
      return merged;
    }

    // =========================================================
    // GAP DETECTION (FIXED: valley + shoulder contrast)
    // =========================================================
    function analyzeGapValley(data, w, h, cy) {
      const bandLeft = Math.floor(w * TUNE.GAP_XL);
      const bandRight = Math.floor(w * TUNE.GAP_XR);
      const bandW = Math.max(1, bandRight - bandLeft);

      const y0 = clamp(cy - 2, 0, h - 1);
      const y1 = clamp(cy + 2, 0, h - 1);

      const step = 2;
      const n = Math.max(1, Math.floor(bandW / step));
      const lumas = new Float32Array(n);

      for (let i = 0; i < n; i++) {
        const x = bandLeft + i * step;
        let s = 0, c = 0;
        for (let y = y0; y <= y1; y++) {
          const idx = (y * w + x) * 4;
          s += lumaOf(data, idx);
          c++;
        }
        lumas[i] = s / c;
      }

      // smooth
      const sm = movingAverage(lumas, 2);

      // find valley (min)
      let minV = 255, minI = 0;
      let mean = 0;
      for (let i = 0; i < sm.length; i++) {
        mean += sm[i];
        if (sm[i] < minV) { minV = sm[i]; minI = i; }
      }
      mean /= Math.max(1, sm.length);

      const win = TUNE.SHOULDER_WIN;
      const leftA = clamp(minI - win * 2, 0, sm.length - 1);
      const leftB = clamp(minI - win, 0, sm.length - 1);
      const rightA = clamp(minI + win, 0, sm.length - 1);
      const rightB = clamp(minI + win * 2, 0, sm.length - 1);

      function avgRange(a, b) {
        if (b <= a) return sm[a] || 0;
        let s = 0, c = 0;
        for (let i = a; i <= b; i++) { s += sm[i]; c++; }
        return s / Math.max(1, c);
      }

      const leftMean = avgRange(leftA, leftB);
      const rightMean = avgRange(rightA, rightB);
      const shoulder = (leftMean + rightMean) / 2;

      const contrast = Math.max(0, shoulder - minV);

      // run length around valley (expand while below threshold)
      const thr = minV + Math.max(6, contrast * 0.40);
      let iL = minI, iR = minI;
      while (iL > 0 && sm[iL - 1] < thr) iL--;
      while (iR < sm.length - 1 && sm[iR + 1] < thr) iR++;

      const runLenPx = (iR - iL + 1) * step;
      const centerX = bandLeft + minI * step;
      const bandCenter = (bandLeft + bandRight) * 0.5;

      return {
        bandW,
        meanL: mean,
        valley: minV,
        shoulder,
        contrast,
        runLen: runLenPx,
        centerX,
        bandCenter
      };
    }

    function gapScoreFromValley(gm) {
      const minRun = Math.max(10, Math.floor(gm.bandW * TUNE.RUN_FRAC));
      const lenScore = clamp(gm.runLen / (minRun * 1.15), 0, 1.8);

      const contrastScore = clamp(gm.contrast / 10.0, 0, 2.0); // 10 = scale for cardboard

      const centerOff = Math.abs(gm.centerX - gm.bandCenter);
      const centerPenalty = clamp(centerOff / (gm.bandW * TUNE.GAP_CENTER_ALLOW), 0, 1.4);

      let score = (0.70 * lenScore) + (0.95 * contrastScore) - (0.45 * centerPenalty);

      if (gm.contrast < TUNE.MIN_CONTRAST) score -= 0.35;
      if (gm.runLen < minRun * 0.85) score -= 0.25;

      return { score, minRun, centerOff };
    }

    function decideGapForBand(data, w, h, cy, bandHalfHeight) {
      const dy = Math.max(3, Math.floor(bandHalfHeight * 0.18));
      const ys = [
        clamp(cy - dy, 0, h - 1),
        clamp(cy,      0, h - 1),
        clamp(cy + dy, 0, h - 1)
      ];

      const scores = [];
      const gms = [];
      for (const y of ys) {
        const gm = analyzeGapValley(data, w, h, y);
        const sc = gapScoreFromValley(gm);
        gms.push(gm);
        scores.push(sc.score);
      }

      const sorted = [...scores].sort((a,b)=>a-b);
      const medScore = sorted[1];

      const isGap = medScore >= TUNE.SCORE_THR;
      return { isGap, score: medScore, gm: gms[1] };
    }

    // =========================================================
    // GLUE GAP MAIN
    // =========================================================
    function processSheetFrame() {
      if (sheetFrozen) return;
      if (video.readyState !== video.HAVE_ENOUGH_DATA) return;

      const m = getCoverMetrics();
      if (!m) return;

      const dw = sheetCanvas.width;
      const dh = sheetCanvas.height;
      if (!dw || !dh) return;

      // ROI (เหมือนเดิม)
      const roiW_disp = Math.round(dw * 0.50);
      const roiH_disp = Math.round(dh * 0.70);
      const roiX_disp = Math.round((dw - roiW_disp) / 2);

      const bottomSafe_disp = Math.round(dh * 0.15);
      let roiY_disp = Math.round((dh - roiH_disp) / 2 - bottomSafe_disp * 0.2);
      roiY_disp = clamp(roiY_disp, 0, dh - roiH_disp);

      // Map ROI to video
      const roiV = dispRectToVideoRect(roiX_disp, roiY_disp, roiW_disp, roiH_disp, m);
      const roiW_v = Math.max(1, Math.round(roiV.w));
      const roiH_v = Math.max(1, Math.round(roiV.h));
      const roiX_v = Math.round(roiV.x);
      const roiY_v = Math.round(roiV.y);

      // HUD mask
      sheetCtx.clearRect(0, 0, dw, dh);
      sheetCtx.save();
      sheetCtx.fillStyle = "rgba(2, 6, 23, 0.60)";
      sheetCtx.fillRect(0, 0, dw, dh);
      sheetCtx.clearRect(roiX_disp, roiY_disp, roiW_disp, roiH_disp);
      sheetCtx.strokeStyle = "rgba(52, 211, 153, 0.5)";
      sheetCtx.lineWidth = 2;
      sheetCtx.setLineDash([10, 10]);
      sheetCtx.strokeRect(roiX_disp, roiY_disp, roiW_disp, roiH_disp);
      sheetCtx.restore();

      // Read ROI pixels
      if (procCanvas.width !== roiW_v || procCanvas.height !== roiH_v) {
        procCanvas.width = roiW_v; procCanvas.height = roiH_v;
      }
      procCtx.drawImage(video, roiX_v, roiY_v, roiW_v, roiH_v, 0, 0, roiW_v, roiH_v);
      const imgData = procCtx.getImageData(0, 0, roiW_v, roiH_v);
      const data = imgData.data;

      // STEP 1: Multi-strip profile => bands
      const profile = extractEdgeProfileMultiStrip(data, roiW_v, roiH_v);
      const bands = findBoxBandsFromProfile(profile, roiH_v);

      const sx = roiW_disp / roiW_v;
      const sy = roiH_disp / roiH_v;

      const results = [];

      for (let k = 0; k < bands.length; k++) {
        const b = bands[k];
        const localY_v = b.cy;
        const drawY = roiY_disp + localY_v * sy;

        const bandHalf = Math.max(6, Math.floor((b.y1 - b.y0 + 1) * 0.5));
        const bandEval = decideGapForBand(data, roiW_v, roiH_v, localY_v, bandHalf);

        // hysteresis
        const id = Math.round(localY_v / 6) * 6;
        let gs = gapStabilizer.get(id);
        if (!gs) gs = { lastIsGap: bandEval.isGap, lastScore: bandEval.score };

        let finalIsGap = bandEval.isGap;
        if (bandEval.score >= TUNE.GRAY_LO && bandEval.score <= TUNE.GRAY_HI) {
          finalIsGap = gs.lastIsGap;
        } else {
          gs.lastIsGap = bandEval.isGap;
        }
        gs.lastScore = bandEval.score;
        gapStabilizer.set(id, gs);

        // width from runLen (stable)
        const gm = bandEval.gm;
        let st = layerStabilizer.get(id);
        const widthV = gm.runLen;

        if (!st) st = { width: widthV };
        else st.width = lerp(st.width, widthV, 0.20);
        layerStabilizer.set(id, st);

        const dispW = Math.max(30, st.width * sx);
        const dispX = roiX_disp + (roiW_disp - dispW) / 2;

        // Decide label/colors
        let status = "OK";
        let boxColor = "#34d399";
        let bgColor = "rgba(52, 211, 153, 0.18)";
        let labelText = `#${k + 1}`;
        let xOffset = 55;

        if (!finalIsGap) {
          status = "NG";
          boxColor = "#ef4444";
          bgColor = "rgba(239, 68, 68, 0.18)";
          labelText = `NO GAP ${k + 1}`;
          xOffset = 82;
        }

        // Draw band box
        sheetCtx.fillStyle = bgColor;
        sheetCtx.fillRect(dispX, drawY - 8, dispW, 16);
        sheetCtx.strokeStyle = boxColor;
        sheetCtx.setLineDash([]);
        sheetCtx.lineWidth = 2;
        sheetCtx.strokeRect(dispX, drawY - 8, dispW, 16);

        // Label (optional debug)
        sheetCtx.fillStyle = boxColor;
        sheetCtx.font = "bold 12px 'JetBrains Mono'";
        let extra = "";
        if (TUNE.DEBUG_LABEL) {
          extra = ` s:${bandEval.score.toFixed(2)} c:${gm.contrast.toFixed(1)} r:${Math.round(gm.runLen)}`;
        }
        sheetCtx.fillText(labelText + extra, roiX_disp - xOffset, drawY + 4);

        results.push({ layer: k + 1, w: dispW, status });
      }

      // Summary
      const boxFound = results.length;
      const noGapCount = results.filter(r => r.status === "NG").length;
      const glueGapCount = boxFound - noGapCount;

      document.getElementById('sum-total').innerText = boxFound;
      document.getElementById('sum-gap').innerText = glueGapCount;
      document.getElementById('sum-ng').innerText = noGapCount;

      // Header status
      const statusGroup = document.getElementById("header-status-group");
      const header = document.getElementById("glue-header");

      if (boxFound < 2) {
        statusGroup.innerHTML = `<div class="gc-status-badge"><i data-lucide="alert-circle"></i> SCANNING</div>`;
        header.className = "glue-compact-header";
      } else if (noGapCount > 0) {
        statusGroup.innerHTML =
          `<div class="gc-status-badge" style="color:#ef4444; background:rgba(239,68,68,0.1); border-color:rgba(248,113,113,0.2)">
            <i data-lucide="x-circle"></i> FAIL
          </div>`;
        header.className = "glue-compact-header status-fail";
      } else {
        statusGroup.innerHTML =
          `<div class="gc-status-badge">
            <i data-lucide="check-circle-2" style="color:#34d399"></i> PASS
          </div>`;
        header.className = "glue-compact-header status-pass";
      }

      // Stats for chart
      const validGaps = results.filter(r => r.status !== "NG").map(r => r.w);
      let avgWidth = 0;
      let uniformity = 100;
      let stdDev = 0;

      if (validGaps.length > 0) {
        const totalW = validGaps.reduce((acc, v) => acc + v, 0);
        avgWidth = totalW / validGaps.length;

        const variance = validGaps.reduce((acc, v) => acc + Math.pow(v - avgWidth, 2), 0) / validGaps.length;
        stdDev = Math.sqrt(variance);

        const totalDev = validGaps.reduce((acc, v) => acc + Math.abs(v - avgWidth), 0);
        const avgDev = totalDev / validGaps.length;
        uniformity = (avgWidth > 0) ? Math.max(0, 100 - ((avgDev / avgWidth) * 100)) : 100;
      }

      const statsHeader = document.getElementById("stats-header");
      if (results.length > 0) {
        statsHeader.style.display = "grid";
        statsHeader.innerHTML = `
          <div class="stat-box">
            <div class="stat-title">Avg Width</div>
            <div class="stat-val">${Math.round(avgWidth)}<span class="stat-unit">px</span></div>
          </div>
          <div class="stat-box">
            <div class="stat-title">Consistency</div>
            <div class="stat-val" style="color:${uniformity > 85 ? '#34d399' : '#fbbf24'}">
              ${Math.round(uniformity)}<span class="stat-unit">%</span>
            </div>
          </div>
        `;
        document.getElementById("empty-scan-msg").style.display = "none";
      } else {
        statsHeader.style.display = "none";
        document.getElementById("empty-scan-msg").style.display = "flex";
      }

      drawBellCurve(validGaps, avgWidth, stdDev);
      lucide.createIcons();
    }

    function drawBellCurve(values, mean, stdDev) {
      distCtx.clearRect(0, 0, distCanvas.width, distCanvas.height);
      if (values.length < 2) return;

      const w = distCanvas.width;
      const h = distCanvas.height;
      const padX = 20;
      const padY = 20;

      const safeSD = Math.max(stdDev, mean * 0.12);
      const minX = mean - 3.5 * safeSD;
      const maxX = mean + 3.5 * safeSD;
      const rangeX = maxX - minX;

      const mapX = (val) => padX + ((val - minX) / rangeX) * (w - 2 * padX);
      const getGaussian = (x) => (1 / (safeSD * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow((x - mean) / safeSD, 2));
      const maxY = getGaussian(mean);

      // histogram
      const binCount = 8;
      const binWidth = rangeX / binCount;
      const bins = new Array(binCount).fill(0);

      values.forEach(v => {
        const binIdx = Math.floor((v - minX) / binWidth);
        if (binIdx >= 0 && binIdx < binCount) bins[binIdx]++;
      });

      const maxBinVal = Math.max(...bins, 1);
      const barScaleY = (h - 2*padY) * 0.7;

      distCtx.fillStyle = "rgba(255, 255, 255, 0.08)";
      bins.forEach((count, i) => {
        const hBar = (count / maxBinVal) * barScaleY;
        const xBar = mapX(minX + i * binWidth);
        const yBar = h - padY - hBar;
        const wBar = ((w - 2*padX) / binCount) - 2;
        if (hBar > 0) distCtx.fillRect(xBar, yBar, wBar, hBar);
      });

      const mapY = (prob) => h - padY - (prob / maxY) * (h - 2 * padY);

      distCtx.beginPath();
      distCtx.moveTo(mapX(minX), h - padY);
      const steps = 60;
      for (let i = 0; i <= steps; i++) {
        const xVal = minX + (rangeX * (i / steps));
        const yVal = getGaussian(xVal);
        distCtx.lineTo(mapX(xVal), mapY(yVal));
      }
      distCtx.lineTo(mapX(maxX), h - padY);
      distCtx.closePath();

      const grad = distCtx.createLinearGradient(0, 0, 0, h);
      grad.addColorStop(0, "rgba(59, 130, 246, 0.4)");
      grad.addColorStop(1, "rgba(59, 130, 246, 0.05)");
      distCtx.fillStyle = grad;
      distCtx.fill();

      distCtx.strokeStyle = "#3b82f6";
      distCtx.lineWidth = 2;
      distCtx.stroke();

      const cx = mapX(mean);
      distCtx.beginPath();
      distCtx.strokeStyle = "rgba(255,255,255,0.3)";
      distCtx.setLineDash([4, 4]);
      distCtx.moveTo(cx, padY);
      distCtx.lineTo(cx, h - padY);
      distCtx.stroke();
      distCtx.setLineDash([]);

      values.forEach(val => {
        const vx = mapX(val);
        const vy = mapY(getGaussian(val));
        const dev = Math.abs(val - mean);
        let color = "#34d399";
        if (dev > 2 * stdDev) color = "#ef4444";
        else if (dev > 1 * stdDev) color = "#fbbf24";

        distCtx.beginPath();
        distCtx.fillStyle = color;
        distCtx.arc(vx, vy, 4, 0, Math.PI * 2);
        distCtx.fill();
      });

      distCtx.fillStyle = "#64748b";
      distCtx.font = "10px Inter";
      distCtx.textAlign = "center";
      distCtx.fillText(Math.round(mean), cx, h - 5);
    }

    function toggleSheetCapture() {
      const btn = document.getElementById("btn-sheet-cap");
      if (sheetFrozen) {
        sheetFrozen = false;
        btn.innerHTML = '<i data-lucide="camera"></i>';
        btn.classList.remove("frozen");
      } else {
        sheetFrozen = true;
        btn.innerHTML = '<i data-lucide="rotate-ccw"></i>';
        btn.classList.add("frozen");
      }
      lucide.createIcons();
    }

    function resetSheetUI() {
      sheetFrozen = false;
      layerStabilizer = new Map();
      gapStabilizer = new Map();

      sheetCtx.clearRect(0, 0, sheetCanvas.width, sheetCanvas.height);
      distCtx.clearRect(0, 0, distCanvas.width, distCanvas.height);

      document.getElementById('sum-total').innerText = "0";
      document.getElementById('sum-gap').innerText = "0";
      document.getElementById('sum-ng').innerText = "0";

      const header = document.getElementById("glue-header");
      header.className = "glue-compact-header";
      document.getElementById("header-status-group").innerHTML =
        `<div class="gc-status-badge"><i data-lucide="minus"></i> READY</div>`;

      document.getElementById("stats-header").style.display = "none";
      document.getElementById("empty-scan-msg").style.display = "flex";

      const btn = document.getElementById("btn-sheet-cap");
      btn.innerHTML = '<i data-lucide="camera"></i>';
      btn.classList.remove("frozen");

      lucide.createIcons();
    }

    // =========================================================
    // TORCH
    // =========================================================
    async function setTorch(on) {
      if (!videoTrack || !torchSupported || !videoTrack.applyConstraints) return false;
      try {
        await videoTrack.applyConstraints({ advanced: [{ torch: !!on }] });
        return true;
      } catch (e) {
        return false;
      }
    }

    function updateTorchUI() {
      const btn = document.getElementById("btn-torch");
      if (!btn) return;
      if (isTorchOn) btn.innerHTML = '<i data-lucide="flashlight-off" style="width:18px;"></i>';
      else btn.innerHTML = '<i data-lucide="flashlight" style="width:18px;"></i>';
      lucide.createIcons();
    }

    async function toggleTorchHold() {
      if (torchOpBusy || captureBusy) return;
      torchOpBusy = true;

      const next = !isTorchOn;
      try {
        if (torchSupported && videoTrack?.applyConstraints) {
          const ok = await setTorch(next);
          if (!ok && next) {
            document.body.classList.add("screen-lamp");
            isTorchOn = true;
            updateTorchUI();
            return;
          }
          isTorchOn = next;
          if (!isTorchOn) document.body.classList.remove("screen-lamp");
          updateTorchUI();
          return;
        }
        isTorchOn = next;
        document.body.classList.toggle("screen-lamp", isTorchOn);
        updateTorchUI();
      } finally {
        torchOpBusy = false;
      }
    }

    // =========================================================
    // COLEX (stub for this file)
    // =========================================================
    function changeMode(m){ document.getElementById("algo-lbl").innerText = m; }
    function resetAll(){ ghostOverlay.classList.remove("active"); setTimeout(()=>ghostOverlay.src="",0); }

    initCamera();
  </script>
</body>
</html>
